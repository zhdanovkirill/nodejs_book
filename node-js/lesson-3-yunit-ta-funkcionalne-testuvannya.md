# Lesson 3 - Юніт- та функціональне тестування

## Типи тестування, тестові фреймворки, відмінності, інструментарій

Тестування є невід'ємною частиною програмного забезпечення. Зазвичай програмісти запускають код, який тестує розроблені ними додатки, при внесенні змін, щоб переконатися, що все працює, як треба. При правильних налаштуваннях цей процес можна автоматизувати, що дозволяє значно заощадити час. Запуск тестів безпосередньо після написання нового коду гарантує збереження функцій, що існували раніше. Таким чином, розробник може бути впевненим у базі коду, особливо коли вона впроваджується у виробниче середовище, щоб користувачі могли взаємодіяти з нею.

### **Підхід до створення тестів**

Досягти якісного написання тестів можна у разі, якщо під час написання тестів орієнтуватися **** на вимоги до продукту. Структура тесту ділиться на три частини:

* Що тестується? Наприклад - метод `ProductsService.addNewProduct`&#x20;
* За яким сценарієм та за яких обставин проводиться тест? Наприклад, перевіряється реакція системи у ситуації, коли методу не передали ціну товару;
* Якими є очікувані результати тестування? Наприклад, у подібній ситуації система відмовляється підтверджувати додавання до неї нового товару.

Нижче наведено приклад такого коду:

{% code lineNumbers="true" %}
```javascript
//1. тестований модуль
describe('Products Service', function() {
  //2. сценарій 
  describe('Add new product', function() {
    // 3. те, чого чекають від тесту
    it('When no price is specified, then the product status is pending approval', ()=> {
      const newProduct = new ProductService().add(...);
      expect(newProduct.status).to.equal('pendingApproval');
    });
  });
});
```
{% endcode %}

Звіт про тестування нагадує документ, що містить виклад вимог до продукту.

<figure><img src="https://lh3.googleusercontent.com/PQ-YbnI10JCh6o8wxXAox0ToVVeJk9iW_p4rtA02a0Oml8WRYzNtq6tlb0puJ8Wg1QNc03lc5IwDZpwwxPz0a7LaX0NaHbNabVt2iC43TmlQG1sJ_XbOUZLP6gkfF1CWL3U_mubIglodWNw4iM5bf9gcw5BiNhAh_LjRAXkxmjx9LQc76VNkFYZ0CA" alt=""><figcaption></figcaption></figure>

Ось як це виглядає на різних рівнях.

### **Різновид тестів**

Ось найбільш важливі типи тестування веб-сайтів:

#### **Юніт-тестування**

Це таке тестування окремих блоків (юнітів), таких як функції або класи, шляхом порівняння вихідних даних з очікуваним результатом:  `expect(fn(5)).to.be(10)`

#### **Інтеграційне тестування**&#x20;

Тестування процесів декількох блоків, разом з їхніми сторонніми ефектами:

{% code lineNumbers="true" %}
```javascript
const flyDroneButton = document.getElementById('fly-drone-button')
flyDroneButton.click()
assert(isDroneFlyingCommandSent())
//або навіть
drone.checkIfFlyingViaBluetooth()
.then(isFlying => assert(isFlying))
```
{% endcode %}

#### **Функціональне тестування (також відоме як e2e)**

Тестування поведінки функцій безпосередньо на готовому продукті шляхом контролю браузера чи веб-сайту. Зазвичай такі тести ігнорують внутрішню структуру застосунку та розглядають його як чорну скриньку.&#x20;

Перейдіть на сторінку "https://localhost:3303"

Введіть "test-user" у полі "#username"&#x20;

Введіть "test-pass" у полі "#password"&#x20;

Натисніть на "#login"&#x20;

Очікуйте перехід на сторінку "https://localhost:3303/dashboard"

Очікуйте, що значення "#name" буде "test-name

### **Типи інструментів тестування**

Інструменти для тестування можна згрупувати за їх функціональними можливостями. Деякі обмежуються однією функціональністю, інші більш універсальні. Для досягнення максимальної гнучкості зазвичай використовують поєднання декількох інструментів.

1. Лаунчери тестів запускають ваші тести у браузері чи Node.js з конфігурацією користувача за допомогою CLI або UI. Такого ж ефекту можна досягнути, відкриваючи браузер вручну ([**Karma**](https://karma-runner.github.io/)**,** [**Jasmine**](http://jasmine.github.io/)**,** [**Jest**](https://facebook.github.io/jest/)**,** [**TestCafe**](https://github.com/DevExpress/testcafe)**,** [**Cypress**](https://www.cypress.io/));
2. Інструменти, що піклуються про структуру тестування, допоможуть організувати тестові файли ([**Mocha**](https://mochajs.org/)**,** [**Jasmine**](http://jasmine.github.io/)**,** [**Jest**](https://facebook.github.io/jest/)**,** [**Cucumber**](https://github.com/cucumber/cucumber-js)**,** [**TestCafe**](https://github.com/DevExpress/testcafe)**,** [**Cypress**](https://www.cypress.io/));
3. Assert-функції перевіряють результат тесту на відповідність очікуваному ([**Chai**](http://chaijs.com/)**,** [**Jasmine**](http://jasmine.github.io/)**,** [**Jest**](https://facebook.github.io/jest/)**,** [**Unexpected**](http://unexpected.js.org/)**,** [**TestCafe**](https://github.com/DevExpress/testcafe)**,** [**Cypress**](https://www.cypress.io/));
4. Інструменти, що генерують і відображають перебіг тесту та його результати([**Mocha**](https://mochajs.org/)**,** [**Jasmine**](http://jasmine.github.io/)**,** [**Jest**](https://facebook.github.io/jest/)**,** [**Karma**](https://karma-runner.github.io/)**,** [**TestCafe**](https://github.com/DevExpress/testcafe)**,** [**Cypress**](https://www.cypress.io/));
5. Mock, spy та stub для ізоляції певних частин тестів та відстеження їх сторонніх ефектів ([**Sinon**](http://sinonjs.org/)**,** [**Jasmine**](http://jasmine.github.io/)**,** [**enzyme**](http://airbnb.io/enzyme/docs/api/)**,** [**Jest**](https://facebook.github.io/jest/)**,** [**testdouble**](https://github.com/testdouble/testdouble.js));
6. Інструменти, що генерують та порівнюють знімки структур компонентів та даних, аби переконатися у застосуванні змін від попередніх запусків ([**Jest**](https://facebook.github.io/jest/)**,** [**Ava**](https://github.com/avajs/ava));
7. Інструменти, що генерують звіти про покриття коду, щоб дізнатись, скільки коду покривається вашими тестами ([**Istanbul**](https://gotwarlost.github.io/istanbul/)**,** [**Jest**](https://facebook.github.io/jest/)**,** [**Blanket**](http://blanketjs.org/));
8. Контролери браузера імітують дії користувача для функціональних тестів ([**Nightwatch**](http://nightwatchjs.org/)**,** [**Nightmare**](http://www.nightmarejs.org/)**,** [**Phantom**](http://phantomjs.org/)**,** [**Casper**](http://casperjs.org/)**,** [**TestCafe**](https://github.com/DevExpress/testcafe)**,** [**Cypress**](https://www.cypress.io/));
9. Інструменти візуальної регресії використовуються для візуального порівняння сайту з попередніми версіями за допомогою методів порівняння зображень ([**Applitools**](https://applitools.com/)**,** [**Percy**](https://percy.io/)**,** [**Wraith**](http://bbc-news.github.io/wraith/)**,** [**WebdriverCSS**](https://github.com/webdriverio-boneyard/webdrivercss)).

Почніть з вибору структури тестування та синтаксису, який вам подобається, бібліотеки assert-функцій та вирішіть, як ви хочете запускати тести. Деякі фреймворки, на зразок [**Jest**](https://facebook.github.io/jest/docs/en/snapshot-testing.html)**,** [**Jasmine**](https://jasmine.github.io/)**,** [**TestCafe**](https://devexpress.github.io/testcafe/) та [**Cypress**](https://www.cypress.io/), мають увесь перелічений функціонал з коробки. Інші ж пропонують лише частковий функціонал, який можна доповнити комбінацією декількох бібліотек (наприклад, [**mocha**](https://mochajs.org/) + [**chai**](https://www.chaijs.com/) + [**sinon**](https://sinonjs.org/)). Найкраще створювати два різних процеси. Один для запуску модульних та інтеграційних тестів, а інший — для функціональних тестів. Усе тому, що функціональні тести зазвичай потребують більше часу, особливо для запуску набору тестів в декількох різних браузерах. Подумайте, коли запускати той чи інший тип тесту. Наприклад: модульний+інтеграційний для кожної зміни, функціональний — лише перед комітами.

## Написання юніт-тестів за допомогою Mocha, для тестування класів та функцій.

### Створення модуля Node

Давайте начнем с написания модуля Node.js, который мы будем тестировать. Этот модуль будет управлять списком элементов TODO. Для начала необходимо настроить среду программирования. Создайте папку с именем проекта в своем терминале. В данном обучающем руководстве будет использоваться имя <mark style="color:yellow;">`todos`</mark>:

```bash
mkdir todos
```

Потім відкрийте цю папку:

```bash
cd todos
```

Тепер ініціалізуйте [npm](https://www.npmjs.com/), оскільки пізніше ми будемо використовувати його функцію командного рядка для запуску тестування:

```bash
npm init -y
```

У нас є лише одна залежність, Mocha, яку ми будемо використовувати для організації та запуску тестів. Для завантаження та встановлення Mocha скористайтеся наступною командою:

```bash
npm i request --save-dev mocha
```

Ми встановимо Mocha як залежність dev, оскільки він не використовується для production. Створимо файл, який міститиме код нашого модуля:

```bash
touch index.js
```

Тепер ми готові створити наш модуль. Відкрийте <mark style="color:blue;">`index.js`</mark>​​​  у текстовому редакторі, наприклад <mark style="color:blue;">`nano`</mark>

```bash
nano index.js
```

Почнемо з визначення класу <mark style="color:yellow;">`Todos`</mark> . Цей клас містить усі функції , необхідні для керування нашим списком TODO. Додайте наступні рядки коду до <mark style="color:blue;">`index.js`</mark>:

{% code title="todos/index.js" lineNumbers="true" %}
```javascript
class Todos {
    constructor() {
        this.todos = [];
    }
}

module.exports = Todos;
```
{% endcode %}

Почнемо із створення класу `Todos`. Його функція `constructor()` не приймає аргументів, тому нам не потрібно надавати значення для створення об'єкта для цього класу. Все, що ми робимо, коли ініціалізуємо об'єкт `Todos`, - це створює властивість `todos`, яка є порожнім масивом.

Лінія `модулів` дозволяє іншим модулям Node.js вимагати нашого класу `Todos`. Без прямого експорту класу тестовий файл, який ми створимо пізніше, зможе використовувати його.

Додамо функцію повернення збереженого масиву `todos:`

{% code title="todos/index.js" lineNumbers="true" %}
```javascript
class Todos {
    constructor() {
        this.todos = [];
    }

    list() {
        return [...this.todos];
    }
}

module.exports = Todos;
```
{% endcode %}

Функція `list()` повертає копію масиву класу. Вона робить копію масиву, використовуючи JavaScript, що деструктурує синтаксис. Ми створюємо копію масиву, щоб зміни, які користувач вносить до масиву, поверненого функцією `list()`, не впливали на масив, який використовується об'єктом `Todos`.

{% hint style="info" %}
Масиви JavaScript – це _довідкові файли_. Це означає, що для будь-якого надання змінної для масиву або виклику функції з масивом як параметр JavaScript звертається до оригінального створеного масиву. Наприклад, якщо у нас є масив з трьома елементами з ім'ям <mark style="color:orange;">`x`</mark> і ми створюємо нову змінну <mark style="color:orange;">`y`</mark>, то <mark style="color:orange;">`y =`</mark>` ``x`, <mark style="color:orange;">`y`</mark> і <mark style="color:orange;">`x`</mark> відносяться до одного і того ж. Всі зміни, що виконуються для масиву з y впливають на змінну <mark style="color:orange;">`x`</mark> і навпаки.
{% endhint %}

Тепер створимо функцію `add()`, яка додає новий елемент TODO:

{% code title="todos/index.js" lineNumbers="true" %}
```javascript
class Todos {
    constructor() {
        this.todos = [];
    }

    list() {
        return [...this.todos];
    }

    add(title) {
        let todo = {
            title: title,
            completed: false,
        }

        this.todos.push(todo);
    }
}

module.exports = Todos;
```
{% endcode %}

Наша функція `add()` бере рядок і поміщає її у властивість `title` нового об'єкта JavaScript. Новий об'єкт також має властивість `completed`, яка за умовчанням встановлюється на `false`. Потім ми додаємо новий об'єкт до нашого масиву TODO.

Важливою функцією менеджера TODO є позначка елементів як завершені. Для виконання цього завдання ми пройдемо в циклі нашим масивом `todos`, щоб знайти елемент TODO, який шукає користувач. Якщо елемент знайдено, позначимо його як завершений. Якщо нічого не знайдено, видамо помилку.

Додайте функцію `complete()`​ наступним чином:

{% code title="" lineNumbers="true" %}
```javascript
class Todos {
    constructor() {
        this.todos = [];
    }

    list() {
        return [...this.todos];
    }

    add(title) {
        let todo = {
            title: title,
            completed: false,
        }

        this.todos.push(todo);
    }

    complete(title) {
        let todoFound = false;
        this.todos.forEach((todo) => {
            if (todo.title === title) {
                todo.completed = true;
                todoFound = true;
                return;
            }
        });

        if (!todoFound) {
            throw new Error(`No TODO was found with the title: "${title}"`);
        }
    }
}

module.exports = Todos;
```
{% endcode %}

Збережіть файл і вийдіть із текстового редактора.

Тепер у нас базовий менеджер TODO, з яким можна експериментувати. Далі перевіримо код вручну, щоб переконатися у роботі програми.

### Ручне тестування коду

На даному етапі ми запустимо функції нашого коду та подивимося на висновок, щоб переконатися, що він відповідає очікуванням. Це називається _тестуванням вручну_. Воно виконується аналогічно найпоширенішим методам тестування, які використовуються програмістами. Хоча пізніше ми автоматизуємо тестування за допомогою Mocha, спочатку протестуємо наш код вручну, щоб мати найкраще уявлення про те, як тестування вручну відрізняється від тестових фреймворків.

Додамо до нашого додатку два елементи TODO і відзначимо один із них як завершений. Запустіть [Node.js REPL](https://www.digitalocean.com/community/tutorials/how-to-use-the-node-js-repl) у тій же папці, що й файл `index.js`

Ви побачите командний рядок `>` REPL, який вказує, що ми можемо ввести код JavaScript.

За допомогою `require()` ми завантажуємо модуль TODO змінну `Todos`. Пам'ятайте, що модуль повертає клас `Todos` за замовчуванням. Тепер інстанцуємо об'єкт цього класу.

Ми можемо використовувати об'єкт `todos` для перевірки роботи реалізації.

Досі ми не бачили жодних висновків у нашому терміналі. Упевнімося, що ми зберегли елемент TODO `run code`, отримавши список всіх наших TODO:

```javascript
const Todos = require('./index');
const todos = new Todos();
todos.add("run code");
todos.list();
```

Ви побачите наступний висновок у вашому REPL:

```javascript
Output
[ { title: 'run code', completed: false } ]
```

Це очікуваний результат: ми маємо один елемент TODO у нашому масиві TODO, і він не завершений за умовчанням.

Додамо інший елемент TODO:

```bash
todos.add("test everything");
```

Відзначимо перший елемент TODO як завершений:

```bash
todos.complete("run code");
```

Тепер наш об'єкт `todos` буде управляти двома елементами: `run code` і `test everything`. TODO `run code` також буде завершено. Підтвердимо це, викликавши `list()` ще раз:

```bash
todos.list();
```

Результат REPL буде виглядати так:

```javascript
Output
[
  { title: 'run code', completed: true },
  { title: 'test everything', completed: false }
]
```

Закрити REPL потрібно так:

```bash
.exit
```

Ми підтвердили, що наш модуль працює належним чином. Хоча ми не помістили наш код у тестовий файл та не використовували тестову бібліотеку, ми вручну протестували код. На жаль, ця форма тестування займе багато часу, якщо її використовувати під час кожної зміни. Далі спробуємо виконати автоматизоване тестування в Node.js і подивимося, чи можна вирішити цю проблему за допомогою тестового фреймворку Mocha.

### Створення першого тесту за допомогою Mocha та Assert

В останньому кроці ми вручну протестували нашу програму. Це працюватиме в окремих випадках, але в міру масштабування модуля цей метод стане менш доцільним. Оскільки тестуються нові функції, необхідно переконатись, що додана функціональність не створила проблем у попередньому варіанті. Ми хотіли б протестувати кожну функцію ще раз для кожної зміни в коді, але виконання цього завдання вручну вимагатиме величезних зусиль і збільшить ймовірність виникнення помилок.

Набагато ефективніше настроїти _автоматичне тестування_. Тестування за сценарієм створюється аналогічно іншим блокам коду. Ми запускаємо наші функції з певними введеннями та перевіряємо їхню дію, щоб переконатися, що вони працюють відповідним чином. У міру зростання бази коду ми автоматизуватимемо тестування. Коли ми прописуємо тести поряд із функціями, то можемо перевірити працездатність всього модуля без необхідності щоразу запам'ятовувати, як використовувати ту чи іншу функцію.

У цьому навчальному посібнику ми використовуємо тестовий фреймворк Mocha з модулем Node.js `assert`. Давайте на практиці подивимося, як вони працюють разом.

Для початку створимо новий файл для зберігання коду тесту:

```bash
touch index.test.js
```

Тепер за допомогою текстового редактора відкрийте файл тестування. Можна використовувати `nano` як раніше:

```bash
nano index.test.js
```

У першому рядку текстового файлу ми завантажимо модуль TODO аналогічно до того, як ми робили в оболонці Node.js. Потім ми завантажимо модуль `assert`, щоб він був на момент створення тестів:&#x20;

{% code title="todos/index.test.js" lineNumbers="true" %}
```javascript
const Todos = require('./index');
const assert = require('assert').strict;
```
{% endcode %}

Властивість `strict` ​​ модуля `assert` дозволить нам використовувати спеціальні тести еквівалентності, рекомендовані Node.js, які також підходять для перевірок надалі, оскільки відповідають за більшу кількість варіантів використання.

Перш ніж приступити до написання тестів, обговоримо, як Mocha організує наш код. Тестування з використанням Mocha, як правило, використовує такі шаблони:

{% code lineNumbers="true" %}
```javascript
describe([String with Test Group Name], function() {
    it([String with Test Name], function() {
        [Test Code]
    });
});
```
{% endcode %}

Зверніть увагу на дві ключові функції: `describe()` та `it()`. Функція `describe()` використовується для угруповання аналогічних тестів. Для Mocha не потрібно запускати тести, але їхнє угруповання спростить підтримку нашого коду тесту. Рекомендується групувати тести таким чином, щоб легше було оновлювати аналогічні разом.

`it()` містить код тесту. Саме тут ми могли б взаємодіяти з функціями нашого модуля та використовувати бібліотеку `assert`. Багато функцій `it()` можуть бути визначені функції `describe()`.

Мета цього розділу полягає у використанні Mocha та `assert` для автоматизації нашого ручного тесту. Ми робитимемо це поступово, почавши з блоку опису. Додайте до файлу наступне, після рядків модуля:

{% code title="todos/index.test.js" lineNumbers="true" %}
```javascript
...
describe("integration test", function() {
});
```
{% endcode %}

За допомогою цього блоку коду ми створили угруповання для наших об'єднаних тестів. _Тести блоку_ перевіряють за однією функцією за раз. _Інтеграційні тести_ перевіряють, наскільки добре функції у модулях чи між ними працюють разом. Коли Mocha запускає наш тест, всі тести цього блоку опису будуть запущені в групі `інтеграційних тестів`.

Давайте додамо функцію `it()`, щоб розпочати тестування нашого коду модуля:

{% code title="todos/index.test.js" lineNumbers="true" %}
```javascript
...
describe("integration test", function() {
    it("should be able to add and complete TODOs", function() {
    });
});
```
{% endcode %}

Зверніть увагу, на назву тесту. Для всіх, хто запустить наш тест, стане зрозуміло, що пройдено, а що — ні. Добре протестований додаток — це, як правило, добре задокументований додаток, і тести можуть бути ефективним способом документування.

Для першого тесту ми створимо новий об'єкт `Todos` і перевіримо, що в ньому немає елементів:

{% code title="todos/index.test.js" lineNumbers="true" %}
```javascript
...
describe("integration test", function() {
    it("should be able to add and complete TODOs", function() {
        let todos = new Todos();
        assert.notStrictEqual(todos.list().length, 1);
    });
});
```
{% endcode %}

Перший новий рядок коду інстанціював новий об'єкт `Todos`, як ми робили в Node.js REPL або іншому модулі. У другому новому рядку ми використовували модуль `assert`.

З модуля `assert` ми використовуємо метод `notStrictEqual()`. Ця функція враховує два параметри: значення, яке необхідно протестувати (називається `фактичне` значення), та значення, яке ми очікуємо отримати (називається `очікуване` значення). Якщо ці обидва аргументи однакові, `notStrictEqual()` видає помилку про непроходження тесту.

Збережіть та закрийте `index.test.js`.

Базовий сценарій буде істинним, тому що довжина має бути `0`, що не дорівнює `1`. Давайте переконаємось у цьому, запустивши Mocha. Для цього нам потрібно буде модифікувати наш файл `package.json`. Відкрийте файл `package.json` у текстовому редакторі:

```bash
nano package.json
```

Тепер у властивості `scripts` змініть його наступним чином:

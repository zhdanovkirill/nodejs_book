---
description: Потоки для читання/запису та перетворення даних
---

# Lesson 2 - Потоки данных

## Потоки для читання/запису та перетворення даних

Вся концепція роботи потоків полягає у передачі даних між програмами в операціях введення/виводу. Використання потоків дозволяє програмі бути незалежною і поєднуватися з іншими програмами для створення більш складної системи.

Обмін даними здійснюється частинами, не чекаючи повного завантаження, що дозволяє ефективно використовувати оперативну пам'ять.

<figure><img src="https://lh5.googleusercontent.com/4SPtjDmcBEn4likxNloX1GKHFop8KwPcbCEMI9Cj_Eu6Vinbsk2hH-49jV32GZh0EUCL_wp7ZYyjH6U3HItrFFO4OhbJ03p20P5Qb7ncK-8y1M_WxDxzJ389JwEpzF8usNlVHQ7AQwfEd2oT4fPqgrW6kgEuYduQz86ckJF6cmnXE_KWnHt_VQ4aEQ" alt=""><figcaption></figcaption></figure>

Наприклад, потрібно знайти певний рядок у файлі великого обсягу. Використання потоку дозволяє отримувати дані частинами і шукати необхідний рядок у цих частинах, при збігу подальше читання файлу можна припинити, заощадивши при цьому час і продуктивні ресурси.

{% hint style="info" %}
За роботу з потоками Node.js відповідає вбудований модуль [**Stream**](https://nodejs.org/api/stream.html#stream), причому всі екземпляри об'єктів потоків є одночасно і екземплярами класу **EventEmitter,** що дозволяє ініціювати і обробляти події.
{% endhint %}

У Node.js є такі потоки:

* **Readable** - потік читання, що отримує дані з переданого джерела (наприклад, читання з файлу)**;**
* **Writable** - потік запису даних (наприклад, збереження даних у файл);
* **Duplex** - потік, що одночасно реалізує і читання, і запис;
* **Transform** - дуплексні потоки, які можуть змінювати або перетворювати дані в міру їх запису та читання.

### Потік Readable

Потік Readable відповідає за читання даних із певного джерела. Приклади потоків читання:

* отримання сервером HTTP запиту;
* отримання клієнтом відповіді на надісланий HTTP запит;
* читання із файлу;
* отримання даних із сокетів тощо;
* потік Readable працює в одному з двох режимів: flowing (процес отримання даних) і paused (режим очікування).

За замовчуванням всі потоки читання починають працювати з режим очікування. Щоб почати читання з джерела, необхідно додати обробник події data, або викликати метод `[ReadableStreamInstance].resume()`, або відправити потік на запис викликом методу pipe()

{% code lineNumbers="true" %}
```javascript
import {readFile} from 'node:fs';

let stream = readFile.createReadStream('./files/data.txt')
setTimeout(
   () =>
       stream.on('data', (data) =>
           console.log(data.toString())
       ),
   3000
)
```
{% endcode %}

Переведення в режим очікування, якщо для даних, що зчитуються, немає призначення, здійснюється викликом методу `[ReadableStreamInstance].pause()`.

{% hint style="info" %}
У разі явного виклику методу **resume()** без наявності обробника події data всі дані потоку будуть втрачені
{% endhint %}

Події Node.js потоку Readable:

* **data** – отримання потоком даних;
* **resume** - ініціюється під час виклику методу resume();
* **pause** - ініціюється під час виклику методу pause();
* **close** - виникає при закритті джерела даних чи самого потоку;
* **end** - генерується, коли з джерела зчитано всі дані;
* **error** - виникнення у потоці помилки, обробнику аргументом передається об'єкт помилки.

### **Потік Writable**

Потік Writable відповідає за запис даних у вказане місце. Приклади потоків запису:

* надсилання HTTP запиту з клієнта на сервер;
* надсилання відповіді на HTTP запит із сервера на клієнт;
* запис даних у файл;
* надсилання даних по сокету.

Розглянемо приклад роботи з потоком Node.js Writable.

{% code lineNumbers="true" %}
```javascript
import {fs} from 'node:fs';

let writableStream = fs.createWriteStream(
   './files/data.txt'
)

writableStream.write('Something important data')
writableStream.end()

writableStream.on('finish', () =>
   console.log('Data was written.')
)
writableStream.on('error', (err) => console.log(err))
```
{% endcode %}

Запис у потік даних здійснюється за допомогою методу `[WritableStreamInstance].write()`, який приймає такі параметри:

* **data** - данні;
* **encode** - кодування (якщо дані рядкового типу);
* **callback** - функцію, яка буде викликана після запису переданих даних.

{% hint style="info" %}
Метод `[WritableStreamInstance].write()` може повернути false у тому випадку, якщо дані на запис надходитимуть у потік занадто швидко, тоді дані не встигатимуть записуватись і почнуть накопичуватися у внутрішньому буфері. Після досягнення ліміту буфера `[WritableStreamInstance].write()` поверне false, тим самим кажучи. що необхідно почекати запису даних, що надійшли. Коли буфер розвантажиться – буде згенеровано подію drain, і тоді можна буде продовжити запис.
{% endhint %}

Після закінчення роботи з потоком Writable викличте метод `[WritableStreamInstance].end()`, щоб вказати, що всі необхідні дані були записані. Виклик методу ініціює подію finish.

Якщо неправильно вказати шлях до файлу для запису даних, буде згенеровано подію error, обробнику якого аргументом буде передано об'єкт помилки.

`writableStream.on('error', (err) => console.log(err))` події Node.js потоку Writable:

* _drain_ - сигналізує можливості продовжити запис після переповнення внутрішнього буфера;
* **finish** - ініціюється після виклику методу `[WritableStreamInstance].end()` та запису у вказане місце всіх даних;
* _close_ - виникає при закритті зазначеного ресурсу призначення даних чи самого потоку;
* _error_ - виникнення у потоці помилки, обробнику аргументом передається об'єкт помилки.

### Потік Duplex

У Node.js Duplex потоками називаються ті потоки, які одночасно і Readable і Writable. Прикладом Duplex потоку є передача даних по сокетах: відправлення даних однією стороною (запис) та прийняття їх іншою (читання).

### Потік Transform

Потоки Transform є різновидом потоків Duplex, їхня відмінність полягає в тому, що перед віддачею вхідні дані видозмінюються (звідси і назва). Приклад потоку Transform є процес шифрування або розшифрування даних.

### Метод pipe()

Для передачі даних з одного потоку до іншого, стосовно об'єкта потоку використовується метод _**pipe()**_. Він також виконує сполучну роль, дозволяючи поєднувати потоки між собою.

{% code lineNumbers="true" %}
```javascript
import {fs} from 'node:fs';


let readStream = fs.createReadStream('./files/from.txt')
let writeStream = fs.createWriteStream('./files/to.txt')

readStream.pipe(writeStream)
```
{% endcode %}

### **Process**

#### **P**rocess.stdin

Потік читання містить стандартний системний потік введення для вашої програми.

Якщо _**process.stdin**_ вказує на термінал(перевіряється викликом `tty.isatty())`, тоді вхідні дані буферизуватимуться рядково. Ви можете вимкнути рядкову буферизацію викликавши `process.stdin.setRawMode(true)`. Однак, майте на увазі, що в цьому випадку обробники системних натискань (таких як ^C і ^D) будуть видалені.

#### **Process.stdout**

Потік запису, що містить стандартний системний висновок для вашої програми. Надсилайте туди дані, якщо вам потрібно передати їх у _stdout_.

#### **Process.stderr**

Потік на запис, що містить стандартне системне виведення помилок для вашої програми. Надсилайте туди дані, якщо вам потрібно передати їх у _stderr_.

## Внутрішній пристрій потоків: буферизація даних, події, методи керування потоками.

### Буферизація

Як записуваний, так і читаний потоки зберігатимуть дані у внутрішньому буфері.

Обсяг потенційно буферизованих даних залежить від опції _highWaterMark_, переданої в конструктор потоку. Для звичайних потоків параметр _highWaterMark_ визначає загальну кількість байтів. Для потоків, що працюють в об’єктному режимі, _highWaterMark_ визначає загальну кількість об’єктів.

Дані буферизуються в доступних для читання потоках, коли реалізація викликає `stream.push(chunk)`. Якщо споживач потоку не викликає `stream.read()`, дані залишатимуться у внутрішній черзі, доки не будуть використані.

<figure><img src="https://lh5.googleusercontent.com/rYPWgjt65ZcoG-qkm39Oq_JyGEcywIslv6t2HB28q13fvB0QZUwOACmkehifrbyN2otIq3i-Y_mRnESh7B6D5ENDH5Tk570sFQKWFWCdhIFVfM4lMHH0uBQYz2jI5WSLslmr2RK51VgRLqMhx25dIL4nW68GfEc2ULAssvKImQwrf1BZTa20yY2v4w" alt=""><figcaption></figcaption></figure>

Щойно загальний розмір внутрішнього буфера читання досягне порогового значення, визначеного _highWaterMark_, потік тимчасово припинить читання даних із базового ресурсу, доки дані, які наразі буферизовані, не будуть використані (тобто потік припинить викликати внутрішній `readable._read( )` метод, який використовується для заповнення буфера читання).

Дані буферизуються в записуваних потоках, коли метод `writable.write(chunk)` викликається повторно. Хоча загальний розмір внутрішнього буфера запису нижчий за порогове значення, встановлене _highWaterMark_, виклики `writable.write()` повертатимуть true. Коли розмір внутрішнього буфера досягне або перевищить _highWaterMark_, буде повернено false.

{% hint style="info" %}
Ключова мета потокового API, зокрема методу `stream.pipe()`, полягає в тому, щоб обмежити буферизацію даних до прийнятних рівнів, щоб джерела та призначення з різними швидкостями не перевантажували доступну пам’ять.
{% endhint %}

Параметр _highWaterMark_ — це порогове значення, а не обмеження: воно визначає кількість даних, які потік буферизує, перш ніж перестане запитувати більше даних. Загалом він не передбачає суворого обмеження пам’яті. Конкретні реалізації потоку можуть застосувати суворіші обмеження, але робити це необов’язково.

Оскільки потоки _Duplex_ і _Transform_ доступні як для читання, так і для запису, кожен з них підтримує два окремих внутрішніх буфера, які використовуються для читання та запису, що дозволяє кожній стороні працювати незалежно від іншої, зберігаючи належний і ефективний потік даних. Наприклад, екземпляри _net.Socket_ — це дуплексні потоки, сторона для читання яких дозволяє споживати дані, отримані з сокета, а сторона для запису дозволяє записувати дані в сокет. Оскільки дані можуть записуватися в сокет швидше або повільніше, ніж дані приймаються, кожна сторона повинна працювати (і буферизуватися) незалежно від іншої.

Механіка внутрішньої буферизації є внутрішньою деталлю реалізації і може бути змінена в будь-який час. Однак для деяких розширених реалізацій внутрішні буфери можна отримати за допомогою `writable.writableBuffer` або `readable.readableBuffer`. Використання цих незадокументованих властивостей не рекомендується.


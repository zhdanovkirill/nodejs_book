# Lesson 7 - Пользователи, авторизация

### Hashing vs Encryption

Хешування та шифрування забезпечують захист конфіденційних даних. Однак майже за всіх обставин паролі слід хешувати, а НЕ шифрувати.

**Hashing** є односторонньою функцією (тобто неможливо «розшифрувати» хеш і отримати початкове значення відкритого тексту). Хешування підходить для підтвердження пароля. Навіть якщо зловмисник отримає хешований пароль, він не зможе ввести його в поле пароля програми та увійти як жертва.

**Encryption** є двосторонньою функцією , тобто вихідний відкритий текст можна отримати. Шифрування підходить для зберігання таких даних, як адреса користувача, оскільки ці дані відображаються у вигляді відкритого тексту в профілі користувача. Хешування їхньої адреси призведе до спотвореного безладу.

У контексті зберігання паролів шифрування слід використовувати лише в граничних випадках, коли необхідно отримати оригінальний відкритий пароль. Це може знадобитися, якщо програмі потрібно використовувати пароль для автентифікації в іншій системі, яка не підтримує сучасний спосіб програмного надання доступу, наприклад OpenID Connect (OIDC). Якщо можливо, слід використовувати альтернативну архітектуру, щоб уникнути необхідності зберігати паролі в зашифрованому вигляді.

### **Як зловмисники зламують хеші паролів**

Хоча неможливо «розшифрувати» хеші паролів, щоб отримати оригінальні паролі, за деяких обставин можна «зламати» хеші.

Основні кроки:

* Виберіть пароль, який, на вашу думку, обрала жертва (наприклад, password1!)
* Обчисліть хеш
* Порівняйте обчислений хеш із хешем жертви. Якщо вони збігаються, ви правильно «зламали» хеш і тепер знаєте текстове значення їхнього пароля.

Цей процес повторюється для великої кількості потенційних паролів-кандидатів. Для вибору потенційних паролів можна використовувати різні методи, зокрема:

* Списки паролів, отриманих з інших зламаних сайтів
* Груба сила (випробування всіх можливих кандидатів)
* Словники або списки поширених паролів

Хоча кількість перестановок може бути величезною, завдяки високошвидкісному апаратному забезпеченню (наприклад, графічним процесорам) і хмарним службам із багатьма орендованими серверами, вартість для зловмисника є відносно невеликою для успішного злому паролів, особливо якщо не дотримуються найкращі методи хешування.

Надійні паролі, які зберігаються за допомогою сучасних алгоритмів хешування та найкращих практик хешування, повинні бути фактично неможливими для зловмисника. Ви як власник програми несете відповідальність за вибір сучасного алгоритму хешування.

### Концепції зберігання паролів

#### Salting

**Salt** — це унікальний випадково згенерований рядок, який додається до кожного пароля під час процесу хешування. Оскільки сіль є унікальною для кожного користувача, зловмисник повинен зламувати хеші по одному, використовуючи відповідну сіль, а не обчислювати хеш один раз і порівнювати його з кожним збереженим хешем. Це значно ускладнює злом великої кількості хешів, оскільки потрібний час зростає прямо пропорційно кількості хешів.

Salting також захищає від зловмисників, які попередньо обчислюють хеші за допомогою веселкових таблиць або пошуку на основі бази даних. Нарешті, соління означає, що неможливо визначити, чи два користувачі мають однаковий пароль, не зламавши хеші, оскільки різні солі призведуть до різних хешів, навіть якщо паролі однакові.

Сучасні алгоритми хешування, такі як Argon2id, bcrypt і PBKDF2, автоматично закріплюють паролі, тому під час їх використання не потрібні додаткові дії.

#### **Peppering**

**Pepper** **** — можна використовувати на додаток до солі, щоб забезпечити додатковий шар захисту. Мета pepper — завадити зловмиснику зламати будь-які хеші, якщо вони мають доступ лише до бази даних, наприклад, якщо вони використали вразливість SQL-ін’єкції або отримали резервну копію бази даних.

Однією з кількох стратегій перперування є хешування паролів як зазвичай (за допомогою алгоритму хешування паролів), а потім HMAC або шифрування хешів за допомогою симетричного ключа шифрування перед збереженням хешу пароля в базі даних, при цьому ключ виконує роль перцю. Стратегії перетворення жодним чином не впливають на функцію хешування пароля.

* Перець розподіляється між збереженими паролями , а не є унікальним , як сіль.
* На відміну від солі-паролю, перець не повинен зберігатися в базі даних.
* Перці є секретами, і їх слід зберігати в «секретних сховищах» або HSM (апаратних модулях безпеки).
* Як і будь-який інший криптографічний ключ, слід розглянути стратегію перцевої ротації.

### Алгоритми хешування паролів

Існує низка сучасних алгоритмів хешування, які були спеціально розроблені для безпечного зберігання паролів. Це означає, що вони мають бути повільними (на відміну від таких алгоритмів, як MD5 і SHA-1, які були розроблені як швидкі), а наскільки вони повільні, можна налаштувати, змінивши [коефіцієнт роботи](https://cheatsheetseries.owasp.org/cheatsheets/Password\_Storage\_Cheat\_Sheet.html#work-factors) .

Основні три алгоритми, які слід розглянути, перераховані нижче:

**Argon2id**

[Argon2](https://en.wikipedia.org/wiki/Argon2) є переможцем [Конкурсу хешування паролів](https://password-hashing.net/) 2015 року . Існує три різні версії алгоритму, і слід використовувати варіант Argon2id, оскільки він забезпечує збалансований підхід до протистояння атакам як на бічних каналах, так і на GPU.

Замість простого фактора роботи, як інші алгоритми, Argon2id має три різні параметри, які можна налаштувати. Argon2id має використовувати один із наведених нижче параметрів конфігурації як базовий мінімум, який включає мінімальний розмір пам’яті (m), мінімальну кількість ітерацій (t) і ступінь паралелізму (p).

* m=37 МіБ, t=1, p=1
* m=15 МіБ, t=2, p=1

Обидва ці параметри конфігурації еквівалентні щодо захисту, який вони забезпечують. Єдина відмінність полягає в компромісі між використанням процесора та оперативної пам’яті.

**scrypt**

[scrypt](https://www.tarsnap.com/scrypt/scrypt.pdf) — це функція виведення ключів на основі пароля, створена  [Colin Percival](https://twitter.com/cperciva).

Як і [Argon2id](https://cheatsheetseries.owasp.org/cheatsheets/Password\_Storage\_Cheat\_Sheet.html#argon2id), scrypt має три різні параметри, які можна налаштувати. scrypt має використовувати один із наведених нижче налаштувань конфігурації як базовий мінімум, який включає параметр мінімальної вартості ЦП/пам’яті (N), розмір блоку (r) і ступінь паралелізму (p).

* N=2^16 (64 MiB), r=8 (1024 байти), p=1
* N=2^15 (32 MiB), r=8 (1024 байти), p=2
* N=2^14 (16 MiB), r=8 (1024 байти), p=4
* N=2^13 (8 MiB), r=8 (1024 байти), p=8
* N=2^12 (4 MiB), r=8 (1024 байти), p=15

Ці параметри конфігурації еквівалентні щодо захисту, який вони забезпечують. Єдина відмінність полягає в компромісі між використанням процесора та оперативної пам’яті.

#### bcrypt

Функція хешування пароля [bcrypt](https://en.wikipedia.org/wiki/bcrypt) має бути другим вибором для зберігання паролів, якщо Argon2id недоступний або для досягнення відповідності FIPS-140 потрібен PBKDF2.

Коефіцієнт роботи має бути настільки великим, наскільки дозволяє продуктивність сервера перевірки, мінімум 10.

#### Обмеження введення

bcrypt має максимальну довжину вхідних даних 72 байти для більшості реалізацій . Щоб захиститися від цієї проблеми, максимальна довжина пароля в 72 байти (або менше, якщо використовувана реалізація має менші обмеження) під час використання bcrypt.

**Попереднє хешування паролів**

Альтернативним підходом є попереднє хешування наданого користувачем пароля за допомогою швидкого алгоритму, такого як SHA-256, а потім хешування отриманого хешу за допомогою bcrypt

```javascript
bcrypt(base64(hmac-sha256(data:$password, key:$pepper)), $salt, $cost)

```

Це небезпечна (але поширена) практика, якої слід уникати через усунення [пароля](https://www.youtube.com/watch?v=OQD3qDYMyYQ) та інші проблеми під час [поєднання bcrypt з іншими хеш-функціями](https://blog.ircmaxell.com/2015/03/security-issue-combining-bcrypt-with.html).

#### PBKDF2

[PBKDF2](https://en.wikipedia.org/wiki/PBKDF2) рекомендований [NIST](https://pages.nist.gov/800-63-3/sp800-63b.html#memsecretver) і має перевірені реалізації FIPS-140. Отже, це має бути кращий алгоритм, коли вони потрібні.

PBKDF2 вимагає, щоб ви вибрали внутрішній алгоритм хешування, наприклад HMAC або низку інших алгоритмів хешування. HMAC-SHA-256 широко підтримується і рекомендований NIST.

Коефіцієнт роботи для PBKDF2 реалізується за допомогою підрахунку ітерацій, який має встановлюватися по-різному залежно від використовуваного внутрішнього алгоритму хешування.

* PBKDF2-HMAC-SHA1: 720 000 ітерацій
* PBKDF2-HMAC-SHA256: 310 000 ітерацій
* PBKDF2-HMAC-SHA512: 120 000 ітерацій

Ці параметри конфігурації еквівалентні щодо захисту, який вони забезпечують.

Якщо PBKDF2 використовується з HMAC і пароль довший за розмір блоку хеш-функції (64 байти для SHA-256), пароль автоматично попередньо хешується. Наприклад, пароль «Це пароль довший за 512 біт, тобто розмір блоку SHA-256» перетворюється на хеш-значення (у шістнадцятковому) **** `fa91498c139805af73f7ba275cca071e78d78675027000c99a9925e2ec92eedd`.&#x20;

Хороша реалізація PBKDF2 виконає цей крок перед дорогою ітераційною фазою хешування, але деякі реалізації виконують перетворення на кожній ітерації. Це може зробити хешування довгих паролів значно дорожчим, ніж хешування коротких паролів. Якщо користувач може надати дуже довгі паролі, існує потенційна вразливість до відмови в обслуговуванні, наприклад, опублікована в [Django](https://www.djangoproject.com/weblog/2013/sep/15/security/) у 2013 році. Ручне попереднє хешування може зменшити цей ризик, але вимагає додавання солі на етапі попереднього хешування.

### **Cookies та Session**

#### **Cookie**

Cookies – певна кількість інформації, що створюється сервером після того, як користувач відвідав сторінку і яка залишається на ПК користувача як окремий текстовий документ.

В основному, куки зберігають ідентифікаційну інформацію, дані про користувача, про характеристики та налаштування, які були вибрані в процесі взаємодії зі сторінкою, а також інші подібні дані, що стосуються службових.

Якщо куки підтримуються браузером, при кожному наступному запиті весь обсяг інформації транспортується від користувача на сервер. Яка користь для сайту з цих даних?

Як правило, ідентифікаційна інформація використовується сервером, щоб:

* Збирати та аналізувати статистику;
* Відстежувати проходження сесії (про значення даного терміна поговоримо далі у статті);
* Авторизувати відвідувача (при іншому розкладі, щоразу потрібно було писати логін та пароль);
* Персоналізувати вибрані клієнтом налаштування при всіх запитах (наприклад, мова продукту або певні товари в кошику).

Якщо розглядати куки з технічного погляду, це текстові документи невеликих розмірів.

Максимальний обсяг файлу cookie – 4096 байт.

Що знаходиться в документі кукі:

* Його назва;
* Значення (те, що транспортується серверу та підлягає обробці під час запиту);
* Домен, що належить куки, і який його одержує;
* URL-шлях у просторі цього домену, де конкретний куки дійсний для нього;
* Термін життя. Куки зберігаються лише певний час, який налаштовується окремо кожному за. Можливо, це буде певний день, час або значення сесії, якщо кукі є до закінчення цієї сесії;
* HTTP (присвоюється лише тоді, коли куки буде застосовуватися лише HTTP);
* Безпека (має на увазі передачу куки тільки через захищений HTTPS);
* Обсяг документів куки в байтах**.**

#### Session

Веб-сервера мають одну важливу особливість, яка полягає в тому, що вони не можуть розпізнавати, звідки щоразу надходять запити (з одного і того ж браузера або з різних).

Це тому, що HTTP протокол «не дозволяє» простежувати хід цих станів і, відповідно, підтримувати безперервний зв'язок з відвідувачем.

Кожен запит проходить обробку окремо, без жодного зв'язку з минулими.

Цю проблему дозволяє вирішити сесія браузера (сеанс) – механізм відстеження запитів від одного браузера, здатний зберегти деякі змінні під час переходів між сторінками веб-продукту.

Зі стартом сесії, на сервері створюється документ, де знаходяться дані про клієнта, його маніпуляції та події, що відбулися в межах однієї сесії. Це може бути перегляд сайту, дії зі складовими деталями сторінок, твір транзакцій та інше.

<figure><img src="https://lh4.googleusercontent.com/X9EIrAZWxHi4r77CcHc7gI_DhY8ce_p66P8B7S0tR3iRqOplggScPUiT_80uG3qjmd3Eem0gIC8E1V5Lu78ZMU8MtmZg4Rmum2NQxh-en1k4GKqA9Sql4TgZGtdaLUHaRsE0mt5GKEdjw48EZKdOOVOcw72mxdvZINFYcVx9pUa-HwjcmfPJ2FbJxQ" alt=""><figcaption></figcaption></figure>

Попередня сесія закінчиться лише в тому випадку, коли буде реалізована одна з умов (залежить від налаштувань):

* Закриття браузера;
* Пройде конкретний відрізок часу, у процесі якого користувач не зробив жодної дії;
* У призначений час доби (наприклад, вечір чи ніч).

### Аутентификация и авторизация

Понятия "аутентификация" и "авторизация" часто употребляются как синонимы, но на самом деле они обозначают два разных процесса.

Якщо коротко, то автентифікація - це перевірка того, ким є юзер, тобто визначення того, що користувач зареєстрований у нашій системі, про що, зокрема, може свідчити наявність даних користувача у нашій базі даних. Авторизація ж - це процес визначення повноважень користувача, тобто. того, до чого користувач має доступ, які дані нашої програми може переглядати, редагувати, видаляти і т.д.

Як приклад порівняння автентифікації та авторизації з реального життя можна навести систему безпеки аеропорту. Спочатку ми пред'являємо паспорт для підтвердження нашої особи (автентифікація, ідентифікація), потім талон для підтвердження нашого доступу на літак (авторизація).

Ознаки аутентифікації:

* визначення того, ким є користувач;
* валідація повноважень (пароль, відповідь на секретне питання, розпізнавання особи тощо);
* зазвичай виконується перед авторизацією;
* зазвичай перетворюється на токен ідентифікації (ID Token).

Ознаки авторизації:

* визначення того, до чого користувач має доступ;
* додаткова перевірка доступу на основі політик (policies) та/або правил (rules);
* зазвичай виконується після автентифікації;
* як правило, перетворюється на токен доступу (Access Token).

<figure><img src="https://lh5.googleusercontent.com/WAYmIUdmnxkljbXZIvQAxPG25vFbVeWfZuNLM-XZHyrW6mvRpgNlLXA0dgLyCvJU4onRW4a9uGWv_vKbopLJNQQPfCT52Y0jm4bYSA0Nk8dEfJJuADPhaVFQac8LcaCzydC1jD6N-zHhZtS7MvXIMld_goVwjhFOGoCZnvtF2G8WMB7TB3j6oja2wQ" alt=""><figcaption></figcaption></figure>

Таким чином, для доступу до програми потрібна як автентифікація, так і авторизація. Якщо користувач не може підтвердити свою особистість (ідентичність, identity), він не матиме доступу. І навіть якщо користувач підтвердив свою особу, але не авторизувався, у доступі йому буде відмовлено.

### Токен

Токени — це фрагменти даних, які містять достатньо інформації, щоб полегшити процес визначення особи користувача або авторизації користувача на виконання дії. Загалом, токени — це артефакти, які дозволяють системам додатків виконувати процес авторизації та автентифікації.

Загальні структури ідентифікації та протоколи використовують стратегії на основі маркерів для захисту доступу до програм і ресурсів. Наприклад, ми можемо використовувати OAuth 2.0 для авторизації та OIDC для автентифікації.

OAuth 2.0 — одна з найпопулярніших систем авторизації. Він розроблений, щоб дозволити програмі отримувати доступ до ресурсів, розміщених на інших серверах від імені користувача. OAuth 2.0 використовує маркери доступу та маркери оновлення

[OpenID Connect (OIDC)](https://auth0.com/intro-to-iam/what-is-openid-connect-oidc/) — це протокол ідентифікації, який виконує автентифікацію користувача, згоду користувача та видачу маркерів. OIDC використовує ID Tokens.

<figure><img src="https://lh5.googleusercontent.com/sQzBbms49tZx_zO0QNQX9Q4YCr_ZihnAOG4VttyWEGMuLqbJVTi81Yl7xwnsVaHc0VEAkxigPcHw5ZHwNDD53MKu4581dP40duv0JyDJKjAgyBYpB8AdfEblQy9aj6g3ZgRkContcvXiBs68YDF4yCu6iagsou-9JkEeURhTssuhinHANtaro3KtLw" alt=""><figcaption></figcaption></figure>

Під токеном у рамках цієї статті мається на увазі [JSON Web Token](https://jwt.io/).

JWT – це відкритий стандарт ([**RFC 7519**](https://datatracker.ietf.org/doc/html/rfc7519)), що визначає компактний та автономний спосіб безпечної передачі даних між сторонами у вигляді об'єкта формату JSON. JWT це стандарт, тобто. всі JWT є токенами, але не всі токени є JWT.

Завдяки відносно невеликому розміру, JWT може передаватися через URL, тіло POST-запиту, HTTP-заголовок і т.д. Як правило, він містить інформацію, достатню для одноразового звернення до БД для отримання необхідних даних про користувача. Валідація токена виконується лише на сервері.

У порівнянні з іншими токенами, такими як прості веб-токени (SWT) або токини мови розмітки затвердження безпеки (SAML), JWT має такі переваги:

* більш компактний розмір;
* більш високий рівень безпеки;
* ширша поширеність;
* легше обслуговування.

JWT може використовуватися для:

* аутентифікації: при успішному вході користувача до системи повертається токен ідентифікації;
* авторизації: одночасно з токеном ідентифікації або за ним користувачеві надається токен доступу, який надалі прикріплюється до кожного запиту користувача на доступ до захищених ресурсів;

{% hint style="info" %}
обміну інформацією: токени відмінно підходять для обміну "таємними" повідомленнями.
{% endhint %}

Інформація, що міститься в токені, може бути перевірена і є довіреною завдяки цифровому підпису (digital sign). Шифрування токена застосовується рідко, хоча така можливість є (йдеться про шифрування вмісту токена). У шаблоні використовують підписані токени (signed tokens).

Токен може бути підписаний за допомогою секрету (secret) (алгоритм [**HMAC**](https://ru.wikipedia.org/wiki/HMAC)) або за допомогою публічного та приватного ключів (public/private key pair) (алгоритм [**RSA**](https://ru.wikipedia.org/wiki/RSA)). У шаблоні використовуються обидва варіанти (просто для прикладу). Коли токен підписаний за допомогою приватного ключа, він може бути підтверджений (перевірений, verify) тільки стороною, яка володіє публічним ключем.

Перед використанням токена перевіряється його сигнатури (signature). Перевірка полягає у визначенні відсутності змін. Це не означає, що ніхто не зможе побачити вміст токена, оскільки він зберігається у вигляді звичайного тексту. Тому в токені не можна зберігати чутливу інформацію, таку як пароль користувача.

### **Refresh Token**

Як згадувалося, з міркувань безпеки маркери доступу можуть бути дійсними протягом короткого періоду часу.

Після закінчення терміну дії клієнтські програми можуть використовувати маркер оновлення, щоб «оновити» маркер доступу. Тобто токен оновлення — це артефакт облікових даних, який дозволяє клієнтській програмі отримувати нові токени доступу без необхідності просити користувача повторно ввійти.

<figure><img src="https://lh4.googleusercontent.com/g3U2nrxWGQ5gUZNEaq5jQlr4tcWS3Ot4tOWsI9wain48FBXIivD2v56bKzWqvPjQWIBp9rp125jNMifDExL5FGLo4o38vWWGvcUZ8ZRMvXgd3dja6NXlk2ryxWw4swXy18f0nq72yij_xZM4odAtRkCgkPmn_PpwLfM3e-zGNe5jzsgCtepfZNVInQ" alt=""><figcaption></figcaption></figure>

Клієнтська програма може отримати новий маркер доступу, доки маркер оновлення дійсний і не минув. Отже, маркер оновлення, який має дуже тривалий термін служби, теоретично може надати нескінченну силу носії маркера, щоб отримати новий маркер доступу для доступу до захищених ресурсів у будь-який час. Носієм маркера оновлення може бути законний або зловмисний користувач. Таким чином, компанії безпеки, такі як Auth0, створюють механізми, щоб гарантувати, що цей потужний токен в основному зберігається та постійно використовується зазначеними сторонами.

### Використання бібліотеки passport.js

#### Що таке Passport.js?

* Passport.js — це просте, ненав’язливе проміжне програмне забезпечення автентифікації Node.js для Node.js.
* Passport.js можна додати до будь-якої веб-програми на основі Express.js.

Passport — це проміжне програмне забезпечення автентифікації для Node.js, яке ми збираємося використовувати для керування сеансами.

#### **Початок роботи**

Напишемо приклад який виконує наступне:

* відкриває форму входу**;**
* відкриває дві захищені сторінки
  * сторінка профілю,
  * захищені нотатки

Ми будемо викристовувати таку структуру:

```
├── app
|   ├── authentication
|   ├── note
|   ├── user
|   ├── index.js
|   └── layout.hbs
├── config
|   └── index.js
├── index.js
└── package.json

```

#### Потік автентифікації Node.js

Наша мета полягає в тому, щоб реалізувати такий процес аутентифікації в нашій програмі за допомогою Passport.js:

1. Користувач вводить ім'я користувача та пароль
2. Програма перевіряє, чи вони збігаються
3. Якщо вони збігаються, надсилається LocalStorage або Set-Cookie заголовок, який використовуватиметься для автентифікації наступних сторінок
4. Коли користувач відвідує сторінки з того самого домену, попередньо встановлений token буде додано до всіх запитів
5. Автентифікувати обмежені сторінки за допомогою token

Щоб налаштувати таку стратегію автентифікації в програмі Node.js за допомогою Passport.js, виконайте ці три кроки:

#### Крок 1: Налаштування Express <a href="#step1settingupexpress" id="step1settingupexpress"></a>

Ми збираємося використовувати Express для серверної структури

{% code lineNumbers="true" %}
```javascript
// file:app/index.js
const express = require('express')
const passport = require('passport')
const session = require('express-session')
const RedisStore = require('connect-redis')(session)

const app = express()
app.use(session({
  store: new RedisStore({
    url: config.redisStore.url
  }),
  secret: config.redisStore.secret,
  resave: false,
  saveUninitialized: false
}))
app.use(passport.initialize())
app.use(passport.session())
```
{% endcode %}

Що ми тут робили?

Перш за все, нам потрібні всі залежності, необхідні для керування сеансами. Після цього ми створили новий екземпляр із  `express-session` модуля, який зберігатиме наші сесії.

Для резервного сховища ми використовуємо Redis, але ви можете використовувати будь-який інший, наприклад MySQL або MongoDB.

#### Крок 2: Налаштування Passport.js для Node.js <a href="#step2settinguppassportjsfornodejs" id="step2settinguppassportjsfornodejs"></a>

Passport.js — чудовий приклад бібліотеки, що використовує плагіни. У цьому посібнику з passport.js ми додаємо  `passport-local` модуль, який дозволяє легко інтегрувати просту локальну стратегію автентифікації за допомогою імен користувачів і паролів.

Заради простоти, у цьому прикладі Passport.js ми не використовуємо друге резервне сховище, а лише екземпляр користувача в пам’яті. У реальних додатках  `findUser` шукатиме користувача в базі даних.

{% code lineNumbers="true" %}
```javascript
// file:app/authenticate/init.js
const passport = require('passport')
const bcrypt = require('bcrypt')
const LocalStrategy = require('passport-local').Strategy

const user = {
  username: 'test-user',
  passwordHash: 'bcrypt-hashed-password',
  id: 1
}

passport.use(new LocalStrategy(
 (username, password, done) => {
    findUser(username, (err, user) => {
      if (err) {
        return done(err)
      }

      // User not found
      if (!user) {
        return done(null, false)
      }

      // Always use hashed passwords and fixed time comparison
      bcrypt.compare(password, user.passwordHash, (err, isValid) => {
        if (err) {
          return done(err)
        }
        if (!isValid) {
          return done(null, false)
        }
        return done(null, user)
      })
    })
  }
))
```
{% endcode %}

Після  `findUser` повернення з нашим об’єктом користувача залишається тільки порівняти хешований пароль користувача та справжній пароль, щоб побачити, чи є відповідність. Завжди зберігайте паролі в хешованому вигляді та використовуйте порівняння за фіксованим часом, щоб уникнути атак за часом.

кщо збіг є, ми допускаємо користувача (повертаючи користувача до паспорта –  `return done(null, user)`), якщо ні, повертаємо неавторизовану помилку (не повертаючи нічого до паспорта –  `return done(null)`).

#### Крок 3: Додавання захищених кінцевих точок <a href="#step3addingprotectedendpoints" id="step3addingprotectedendpoints"></a>

Щоб додати захищені кінцеві точки, ми використовуємо шаблон проміжного програмного забезпечення, який використовує Express. Для цього давайте спочатку створимо проміжне програмне забезпечення автентифікації:

{% code lineNumbers="true" %}
```javascript
// file:app/authentication/middleware.js
function authenticationMiddleware () {
  return function (req, res, next) {
    if (req.isAuthenticated()) {
      return next()
    }
    res.redirect('/')
  }
}
```
{% endcode %}

Він має лише одну роль, якщо користувач автентифікований (має потрібні файли cookie); він просто викликає наступне проміжне програмне забезпечення. В іншому випадку він перенаправляє на сторінку, де користувач може увійти.

Використовувати його так само просто, як додати нове проміжне програмне забезпечення до визначення маршруту.

{% code lineNumbers="true" %}
```javascript
// file:app/user/init.js
const passport = require('passport')

app.get('/profile', passport.authenticationMiddleware(), renderProfile)
```
{% endcode %}

### Google и Facebook

Використання в бібліотеці Node.js `passport.js`також дозволяє здійснювати аутентифікацію через соціальні мережі. Розглянемо автентифікацію через облікові записи Google і Facebook.

Для аутентифікації через Google потрібна установка модуля `passport-google-oauth`.

```
npm install passport-google-oauth --save
```

Модуль підтримує протоколи OAuth 1.0 і OAuth 2.0, але тут розглянемо саме OAuth 2.0 через те, що він є новішою версією.

{% code title="app.js" lineNumbers="true" %}
```javascript
const express = require('express'),
  app = express(),
  session = require('express-session'),
  passport = require('passport'),
  GoogleStrategy = require('passport-google-oauth')
    .OAuth2Strategy,
  flash = require('connect-flash')

const host = '127.0.0.1'
const port = 7000

passport.serializeUser((user, done) => done(null, user))
passport.deserializeUser((user, done) => done(null, user))

function checkAuth() {
  return app.use((req, res, next) => {
    if (req.user) next()
    else res.redirect('/login')
  })
}

app.use(express.json())
app.use(express.urlencoded({ extended: true }))
app.use(session({ secret: 'you secret key' }))
app.use(flash())
app.use(passport.initialize())
app.use(passport.session())

passport.use(
  new GoogleStrategy(
    {
      clientID: 90876745, //YOUR GOOGLE_CLIENT_ID
      clientSecret: '35revr-sdv6-3tswa-vzd', //YOUR GOOGLE_CLIENT_SECRET
      callbackURL:
        'http://www.yourdomain.com/auth/google/callback',
    },
    (accessToken, refreshToken, profile, done) => {
      return done(null, profile)
    }
  )
)

app.get('/login', (req, res) => {
  res.send('Login page. Please, authorize.')
})

app.get(
  '/auth/google',
  passport.authenticate('google', {
    scope: ['email', 'profile'],
  })
)

app.get(
  '/auth/google/callback',
  passport.authenticate('google', {
    failureRedirect: '/login',
    successRedirect: '/home',
  })
)

app.get('/home', checkAuth(), (req, res) => {
  res.send("Home page. You're authorized.")
})

app.listen(port, host, function () {
  console.log(`Server listens http://${host}:${port}`)
})
```
{% endcode %}

Стратегії аутентифікації `GoogleStrategy`передаються два параметри:

* об'єкт з параметрами вашого облікового запису Google ( `GOOGLE_CLIENT_ID`та `GOOGLE_CLIENT_SECRET`) та вказівкою маршруту, до якого потрібно звернутися після процесу аутентифікації;
* функція, що описує логіку аутентифікації та встановлює кінцевий результат; приймає такі параметри:
  * `accessToken`;
  * `refreshToken`;
  * `profile`- дані профілю користувача з облікового запису Google;
  * `done`- функція, за допомогою якої задається результат аутентифікації (після її виклику відбувається перехід на вказаний в callbackURL маршрут).

Сама автентифікація починається з звернення до маршруту `/auth/google`, в якому за допомогою методу `passport.authenticate()`вказується тип стратегії ( `google`), що використовується, і параметри так званого [scope](https://developers.google.com/identity/protocols/googlescopes) .

У маршруті `/auth/google/callback`вказується, які маршрути необхідно перейти у разі успішної чи невдалої аутентифікації.

Перевірка авторизованості користувача здійснюється за наявності об'єкта `user`об'єкт запиту.

Аутентифікація через Facebook практично ідентична аутентифікації через Google. Спочатку необхідно встановити модуль `passport-facebook`.

```javascript
npm install passport-facebook --save
```

Тепер необхідно замінити опис стратегії та маршрутів-обробників з прикладу автентифікації через Google на наступне.

{% code lineNumbers="true" %}
```javascript
passport.use(new FacebookStrategy({
    clientID: 90876745, //YOUR FACEBOOK_APP_ID
    clientSecret: '35revr-sdv6-3tswa-vzd', //YOUR FACEBOOK_APP_SECRET
    callbackURL: "http://www.yourdomain.com/auth/facebook/callback"
    },
    (accessToken, refreshToken, profile, done) => {
        return done(null, profile);
    })
);

app.get('/auth/facebook', passport.authenticate('facebook'));

app.get('/auth/facebook/callback', passport.authenticate(facebook, {
    failureRedirect: '/login',
    successRedirect: '/home'
}));
```
{% endcode %}

### Резюме

В цьому розділі ми розглянули авторизацію через UI в систему а також побачили як можна викоритовувати різні стратегії автентифікації Facebook або Google. Ви можете знайти більше стратегій на [http://passportjs.org/](http://passportjs.org/).

### **Додаткові метеріали**

#### **Що таке Redis?**

* Redis — це сховище структури даних із відкритим кодом (ліцензія BSD), яке використовується як база даних, кеш-пам’ять і брокер повідомлень.
* Redis розроблено для підтримки різних типів абстрактних структур даних, таких як рядки, хеші, списки, набори, відсортовані набори із запитами діапазону, растрові зображення, гіперлоги та геопросторові індекси із запитами радіусу.

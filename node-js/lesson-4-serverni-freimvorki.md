# Lesson 4 - Серверні фреймворки

## Вступ

Під час перегляду веб-сторінки в браузері ми надсилаємо запит на інший комп'ютер в Інтернеті, який надсилає у відповідь веб-сторінку. Комп'ютер, з яким ви взаємодієте через Інтернет, називається веб-сервером. Веб-сервер отримує запити HTTP від клієнтів, у тому числі від вашого браузера, і надсилає їм відповіді HTTP, наприклад, сторінки HTML або код JSON з API.

Для виведення веб-сторінки сервер використовує різноманітне програмне забезпечення. Програмне забезпечення може бути клієнтським чи серверним. _Клієнтське програмне забезпечення_ відповідає за виведення контенту, наприклад, за кольори панелі навігації та стилі тексту. _Серверне програмне забезпечення_ відповідає за обмін, обробку та зберігання даних. За обробку мережевих запитів вашого браузера та взаємодію з базами даних в основному відповідає серверний код.

Node.js дозволяє розробникам використовувати JavaScript для створення серверного коду, хоча традиційно ця мова використовувалася в браузері для створення коду клієнта. Об'єднання клієнтського та серверного коду в одному середовищі розробки спрощує створення веб-серверів, і тому Node.js став популярним інструментом для написання серверного коду.

У цьому посібнику ми навчимося створювати веб-сервери за допомогою _npm_ - модуля `express`, що входить до складу Node.js. Ми створимо веб-сервери, які зможуть повертати дані JSON, CSV-файли та веб-сторінки HTML.

## Базові поняття та робота з Express

У традиційних динамічних веб-сайтах, веб-додаток чекає на HTTP-запит від веб-браузера (або іншого клієнта). Коли запит отримано, програма визначає, яку дію необхідно виконати на основі URL шаблону і, можливо, пов'язаної інформації, що міститься в даних POST або GET. Залежно від того, що потрібно, Express може потім читати або записувати дані з бази даних або виконувати інші завдання, відповідно до отриманого запиту. Потім програма повертає відповідь у веб-браузер, часто динамічно створюючи HTML-сторінку для відображення браузером, вставляючи вилучені дані в заповнювачі HTML шаблону.

Express надає методи, що дозволяють вказати, яка функція викликається для конкретного HTTP запиту (`GET`, `POST`, `SET`, etc.), і URL шаблон ("Route"), а також методи, що дозволяють вказати, який механізм шаблону ("view") використовується, де знаходяться шаблони файлів і який шаблон використовуватиме виведення відповіді. Ви можете використовувати Express middleware для додавання підтримки cookies, сеансів, і користувачів, отримання `POST`/`GET` параметрів, і т.д. Ви можете використовувати будь-який механізм бази даних, який підтримується Node (Express не визначає поведінку, пов'язану з базою даних).

У наступних розділах пояснюються деякі загальні моменти, які ви побачите під час роботи з кодом _Express_ and _Node_.

### Helloworld Express <a href="#helloworld_express" id="helloworld_express"></a>

Спочатку давайте розглянемо стандартний приклад Express Hello World (ми обговоримо кожну частину цього нижче та у наступних розділах).

{% hint style="info" %}
Якщо у вас вже встановлено Node та Express, ви можете зберегти цей код у файлі з ім'ям app.js і запустити його в командному рядку, викликавши `node app.js`
{% endhint %}

{% code lineNumbers="true" %}
```javascript
var express = require('express');
var app = express();

app.get('/', function(req, res) {
  res.send('Hello World!');
});

app.listen(3000, function() {
  console.log('Example app listening on port 3000!');
});
```
{% endcode %}

Перші два рядки вимагають () (імпорт) модуля Express та створення програми Express. Цей об'єкт, який традиційно називається app, має методи для маршрутизації HTTP-запитів, налаштування проміжного програмного забезпечення, рендерингу уявлень HTML, реєстрації механізму шаблонів та зміни параметрів програми, які керують поведінкою програми (наприклад, режим середовища, чи чутливі визначення маршруту до регістру) . , і т.д.)

Середня частина коду (три рядки, що починаються з app.get) показує визначення маршруту. Метод app.get () вказує колбек-функцію, яка буде викликатися щоразу, коли є HTTP-запит GET шляхом ('/') щодо кореня сайту. Колбек-функція приймає запит та об'єкт відповіді як аргументи і просто викликає send() для відповіді, щоб повернути рядок «Hello World!»

Останній блок запускає сервер через порт 3000 і друкує коментар журналу в консоль. Коли сервер працює, ви можете перейти до `localhost: 3000` у вашому браузері, щоб побачити повернутий приклад відповіді.

### Імпорт та створення модулів

Модуль - це бібліотека / файл JavaScript, який можна імпортувати в інший код за допомогою функції require () Node. Express сам по собі є модулем, як і проміжне програмне забезпечення та бібліотеки баз даних, які ми використовуємо в наших програмах Express.

Наведений нижче код показує, як ми імпортуємо модуль на ім'я, використовуючи як приклад платформу Express. Спочатку ми викликаємо функцію require (), визначаючи ім'я модуля у вигляді рядка («express») та викликаючи повернутий об'єкт для створення програми Express. Потім ми можемо отримати доступ до властивостей та функцій об'єкта програми.

{% code lineNumbers="true" %}
```javascript
var express = require('express');
var app = express();
```
{% endcode %}

Ви також можете створювати власні модулі, які можна імпортувати таким же чином.

{% hint style="info" %}
Створіть свої власні модулі, тому що це дозволяє вам організувати ваш код у керовані частини - монолітну однофайлову програму важко зрозуміти і підтримувати. Використання модулів також допомагає вам керувати простором імен, оскільки під час використання модуля імпортуються лише ті змінні, які ви явно експортували.
{% endhint %}

Щоб зробити об'єкти доступними поза модулем, вам просто потрібно призначити їх об'єкту експорту. Наприклад, модуль `square.js` нижче являє собою файл, який експортує методи `area()` та `perimeter()`:

{% code lineNumbers="true" %}
```javascript
exports.area = function(width) { return width * width; };
exports.perimeter = function(width) { return 4 * width; };
```
{% endcode %}

Ми можемо імпортувати цей модуль, використовуючи `require ()`, а потім викликати експортовані методи, як показано:

{% code lineNumbers="true" %}
```javascript
var square = require('./square'); // Here we require() the name of the file without the (optional) .js file extension
console.log('The area of a square with a width of 4 is ' + square.area(4));
```
{% endcode %}

{% hint style="info" %}
Ви також можете вказати абсолютний шлях до модуля (або ім'я, як ми на початку).
{% endhint %}

Якщо ви хочете експортувати повний об'єкт в одному призначенні, а не створювати його за однією властивістю за один раз, призначте його для `module.exports`, як показано нижче (ви також можете зробити це, щоб зробити корінь об'єкта експорту конструктором або іншою функцією) :

{% code lineNumbers="true" %}
```javascript
module.exports = {
  area: function(width) {
    return width * width;
  },

  perimeter: function(width) {
    return 4 * width;
  }
};e
```
{% endcode %}

### Использование асинхронных API <a href="#ispolzovanie_asinkhronnykh_api" id="ispolzovanie_asinkhronnykh_api"></a>

JavaScript часто використовує асинхронні, а не синхронні API для операцій, виконання яких може зайняти деякий час. Синхронний API - це той, у якому кожна операція має завершитись до початку наступної операції. Наприклад, такі функції журналу є синхронними та виводять текст на консоль по порядку (перший, другий).

{% code lineNumbers="true" %}
```javascript
console.log('First');
console.log('Second');
```
{% endcode %}

На відміну від цього, асинхронний API - це той, у якому API почне операцію і відразу повернеться (до завершення операції). Після завершення операції API використовуватиме деякий механізм для виконання додаткових операцій. Наприклад, наведений нижче код виведе "Second, First", тому що хоча метод setTimeout() викликається першим і повертається негайно, операція не завершується протягом декількох секунд.

{% code lineNumbers="true" %}
```javascript
setTimeout(function() {
   console.log('First');
   }, 3000);
console.log('Second');
```
{% endcode %}

Використання асинхронних API-інтерфейсів, що не блокують, ще більш важливе в Node, ніж у браузері, оскільки Node - це однопотокове середовище виконання, кероване подіями. "Однопотоковий" означає, що всі запити до сервера виконуються в одному потоці (а не породжуються в окремих процесах). Ця модель надзвичайно ефективна з точки зору швидкості та ресурсів сервера, але це означає, що якщо будь-яка з ваших функцій викликає синхронні методи, виконання яких займає багато часу, вони блокуватимуть не тільки поточний запит, але й будь-який інший запит, що обробляється вашим веб-додатком.

Є кілька способів, якими асинхронний API повідомляє вашу програму про те, що вона завершена. Найпоширеніший спосіб - зареєструвати колбек-функцію при виклику асинхронного API, який буде викликатись після завершення операції. Це підхід, використаний вище.

{% hint style="info" %}
Використання колбеків може бути досить «брудним», якщо у вас є послідовність залежних асинхронних операцій, які мають виконуватися по порядку, тому що це призводить до кількох рівнів вкладених колбеків. Ця проблема широко відома як «пекло колбеків». Цю проблему можна вирішити за допомогою гарних методів кодування, використання такого модуля, як `async`, або навіть переходу до функцій `ES6`, таких як Promises.
{% endhint %}

{% hint style="info" %}
Загальною угодою для Node та Express є використання колбеків з помилками. У цій угоді перше значення у ваших колбек-функціях є значенням помилки, тоді як наступні аргументи містять дані про успіх. У цьому блозі є добре пояснення того, чому цей підхід корисний: шлях Node.js - розуміння колбеків з помилками (fredkschott.com).
{% endhint %}

### Створення обробників маршруту

У нашому прикладі Hello World Express ми визначили функцію обробника маршруту (колбека) для HTTP-запитів GET до кореня сайту ('/').

{% code lineNumbers="true" %}
```javascript
app.get('/', function(req, res) {
  res.send('Hello World!');
});
```
{% endcode %}

Колбек-функція приймає запит та об'єкт відповіді як аргументи. У цьому випадку метод просто викликає send() у відповіді, щоб повернути рядок «Hello World!» Існує ряд інших методів відповіді для завершення циклу запит / відповідь, наприклад, ви можете викликати res.json () для надсилання відповіді JSON або res.sendFile () для надсилання файлу.

{% hint style="info" %}
Ви можете використовувати будь-які імена аргументів, які вам подобаються у колбек-функціях. При виклику колбека перший аргумент завжди буде запитом, а другий завжди буде відповіддю. Має сенс назвати їх так, щоб ви могли ідентифікувати об'єкт, з яким працюєте, у тілі колбека.
{% endhint %}

Об'єкт програми Express також надає методи для визначення обробників маршрутів для всіх інших HTTP-дієслів, які в основному використовуються однаково: post(), put(), delete(), options(), trace(), copy( ), lock() , mkcol (), move (), purge (), propfind (), proppatch (), unlock (), report (), mkactivity (), checkout (), merge (), m-search (), notify () , subscribe (), unsubscribe (), patch (), search () та connect ().

Існує спеціальний метод маршрутизації app.all(), який буде викликатись у відповідь на будь-який метод HTTP. Це використовується для завантаження функцій проміжного програмного забезпечення певним шляхом для всіх методів запиту. У наступному прикладі (з документації Express) показаний обробник, який виконуватиметься для запитів до / secret незалежно від дієслова HTTP (за умови, що він підтримується модулем http).

{% code lineNumbers="true" %}
```javascript
app.all('/secret', function(req, res, next) {
  console.log('Accessing the secret section ...');
  next(); // pass control to the next handler
});
```
{% endcode %}

Маршрути дозволяють зіставляти певні шаблони символів в URL-адресі, витягувати деякі значення з URL-адреси і передавати їх як параметри обробнику маршруту (як атрибути об'єкта запиту, що передається як параметр).

Часто корисно групувати обробники маршрутів для певної частини сайту та отримувати до них доступ за допомогою загального префікса маршруту (наприклад, сайт з вікі може мати всі пов'язані з вікі маршрути в одному файлі та мати до них доступ із префіксом маршруту з /віки/). У Express це досягається за допомогою об'єкта express.Router. Наприклад, ми можемо створити наш вікі-маршрут у модулі з ім'ям wiki.js, а потім експортувати об'єкт Router, як показано нижче:

{% code lineNumbers="true" %}
```javascript
// wiki.js - Wiki route module

var express = require('express');
var router = express.Router();

// Home page route
router.get('/', function(req, res) {
  res.send('Wiki home page');
});

// About page route
router.get('/about', function(req, res) {
  res.send('About this wiki');
});

module.exports = router;
```
{% endcode %}

{% hint style="info" %}
Додавання маршрутів до об'єкта Router аналогічне додаванню маршрутів до об'єкта програми.
{% endhint %}

Щоб використовувати маршрутизатор у нашому головному файлі програми, нам знадобиться () модуль route (wiki.js), а потім викличте use () у додатку Express, щоб додати маршрутизатор у шлях обробки проміжного програмного забезпечення. Ці два маршрути будуть доступні з / wiki / та / wiki / about /.

{% code lineNumbers="true" %}
```javascript
var wiki = require('./wiki.js');
// ...
app.use('/wiki', wiki);
```
{% endcode %}

### Використання middleware

Middleware широко використовується в програмах Express для завдань від обслуговування статичних файлів до обробки помилок та стиснення HTTP-відповідей. Беручи до уваги, що функції маршруту закінчують цикл запиту-відповіді HTTP, повертаючи деяку відповідь клієнту HTTP, функції middleware зазвичай виконують деяку операцію над запитом або відповіддю і потім викликають наступну функцію в «стеку», яка може бути великою кількістю middleware або маршруту обробник. Порядок виклику middleware залежить від розробника програми.

{% hint style="info" %}
middleware може виконувати будь-яку операцію, виконувати будь-який код, вносити зміни до об'єкта запиту та відповіді, а також може завершувати цикл запит-відповідь. Якщо він не завершує цикл, він повинен викликати next (), щоб передати керування наступною функцією middleware (або запит залишиться завислим).
{% endhint %}

Більшість програм використовують стороннє проміжне програмне забезпечення для спрощення загальних завдань веб-розробки, таких як робота з файлами cookie, сесіями, автентифікацією користувача, доступом до даних запитів POST і JSON, ведення журналу тощо. Список пакетів проміжного програмного забезпечення, що підтримуються командою Express можна знайти. (який також включає інші популярні сторонні пакети). Інші експрес-пакети доступні у диспетчері пакетів NPM.

Для використання стороннього middleware спочатку необхідно встановити його у свою програму за допомогою NPM. Наприклад, щоб встановити middleware засобу реєстрації HTTP-запитів morgan, ви повинні зробити таке:

```bash
$ npm install morgan
```

Потім ви можете викликати use () для об'єкта Express, щоб додати middleware в стек:

{% code lineNumbers="true" %}
```javascript
var express = require('express');
var logger = require('morgan');
var app = express();
app.use(logger('dev'));
...
```
{% endcode %}

{% hint style="info" %}
Middleware та функції маршрутизації викликаються в порядку, в якому вони були оголошені. Для деякого middleware важливий порядок (наприклад, якщо middleware сеансу залежить від middleware cookie, спочатку потрібно додати обробник cookie). Майже завжди трапляється так, що middleware викликається перед налаштуванням маршрутів, інакше ваші обробники маршрутів не матимуть доступу до функцій, доданих вашим middleware.
{% endhint %}

Ви можете написати власні функції middleware, і вам, ймовірно, доведеться це зробити (хоча б для створення коду обробки помилок). Єдина різниця між функцією middleware та зворотним викликом обробника маршруту полягає в тому, що функції middleware мають третій аргумент, `next()`.

Ви можете додати функцію middleware в ланцюжок обробки за допомогою app.use () або app.add (), залежно від того, чи хочете ви застосувати middleware до всіх відповідей або відповідей з певним дієсловом HTTP (GET, POST і т.д.). ). Маршрути задаються однаково в обох випадках, хоча маршрут є обов'язковим при виклику app.use ().

У наведеному нижче прикладі показано, як можна додати функцію middleware, використовуючи обидва методи, а також з/без маршруту.

{% code lineNumbers="true" %}
```javascript
var express = require('express');
var app = express();

// An example middleware function
var a_middleware_function = function(req, res, next) {
  // ... perform some operations
  next(); // Call next() so Express will call the next middleware function in the chain.
}

// Function added with use() for all routes and verbs
app.use(a_middleware_function);

// Function added with use() for a specific route
app.use('/someroute', a_middleware_function);

// A middleware function added for a specific HTTP verb and route
app.get('/', a_middleware_function);

app.listen(3000);
```
{% endcode %}

{% hint style="info" %}
В наведеному прикладі оголошена функція middleware окремо, а потім встановлюємо її як колбек. У нашій попередній функції обробника маршруту ми оголосили колбек-функцію, коли вона використовувалася. У JavaScript будь-який підхід є допустимим.
{% endhint %}

Документація Express містить набагато більше відмінної інформації щодо використання та написання middleware Express.

### Обслуговування статичних файлів

Ви можете використовувати проміжне програмне забезпечення express.static для обслуговування статичних файлів, включаючи ваші зображення, CSS та JavaScript (static() - єдина функція проміжного програмного забезпечення, яка фактично є частиною Express). Наприклад, ви повинні використовувати рядок нижче для обслуговування зображень, файлів CSS і JavaScript з каталогу з ім'ям public на тому ж рівні, де ви викликаєте вузол:

{% code lineNumbers="true" %}
```javascript
app.use(express.static('public'));
```
{% endcode %}

Будь-які файли в публічному каталозі обслуговуються шляхом додавання їх імені файлу (щодо базового «публічного» каталогу) до базового URL. Так наприклад:

{% code lineNumbers="true" %}
```javascript
http://localhost:3000/images/dog.jpg
http://localhost:3000/css/style.css
http://localhost:3000/js/app.js
http://localhost:3000/about.html
```
{% endcode %}

Ви можете викликати static() кілька разів для обслуговування кількох каталогів. Якщо файл не може бути знайдений однією функцією проміжного програмного забезпечення, він буде просто переданий наступному проміжному програмному забезпеченню (порядок виклику проміжного програмного забезпечення базується на вашому порядку оголошення).

{% code lineNumbers="true" %}
```javascript
app.use(express.static('public'));
app.use(express.static('media'));
```
{% endcode %}

Ви також можете створити віртуальний префікс для статичних URL-адрес, замість додавання файлів до базової URL-адреси. Наприклад, тут ми вказуємо шлях монтування, щоб файли завантажувалися з префіксом "/media":

{% code lineNumbers="true" %}
```javascript
app.use('/media', express.static('public'));
```
{% endcode %}

Тепер ви можете завантажувати файли в публічному каталозі з префікса / media path.

{% code lineNumbers="true" %}
```javascript
http://localhost:3000/media/images/dog.jpg
http://localhost:3000/media/video/cat.mp4
http://localhost:3000/media/cry.mp3
```
{% endcode %}

### Обробка помилок

Помилки обробляються однією або декількома спеціальними функціями проміжного програмного забезпечення, які мають чотири аргументи замість трьох звичайних: (err, req, res, next). Наприклад:

{% code lineNumbers="true" %}
```javascript
app.use(function(err, req, res, next) {
  console.error(err.stack);
  res.status(500).send('Something broke!');
});
```
{% endcode %}

Вони можуть повертати будь-який необхідний контент, але повинні викликатись після всіх інших app.use () і маршрутизувати виклики, щоб вони були останнім проміжним ПЗ у процесі обробки запитів!

Express поставляється з вбудованим обробником помилок, який піклується про всі помилки, що залишилися, які можуть виникнути в додатку. Ця middleware error handling за замовчуванням додається до кінця стека функцій middleware. Якщо ви передаєте помилку в next () і не обробляєте її в error handling, вона буде оброблена; помилка буде записана клієнту з трасуванням стека.

{% hint style="info" %}
Трасування стека не включено у виробниче середовище. Щоб запустити його у виробничому режимі, необхідно встановити змінне середовище NODE\_ENV у «виробництво».
{% endhint %}

{% hint style="info" %}
HTTP404 та інші коди стану помилка не вважаються помилками. Якщо ви хочете впоратися з цим, можна додати функцію middleware для цього. Для отримання додаткової інформації див. FAQ.
{% endhint %}

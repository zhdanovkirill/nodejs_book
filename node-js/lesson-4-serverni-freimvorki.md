# Lesson 4 - Серверні фреймворки

## Вступ

Під час перегляду веб-сторінки в браузері ми надсилаємо запит на інший комп'ютер в Інтернеті, який надсилає у відповідь веб-сторінку. Комп'ютер, з яким ви взаємодієте через Інтернет, називається веб-сервером. Веб-сервер отримує запити HTTP від клієнтів, у тому числі від вашого браузера, і надсилає їм відповіді HTTP, наприклад, сторінки HTML або код JSON з API.

Для виведення веб-сторінки сервер використовує різноманітне програмне забезпечення. Програмне забезпечення може бути клієнтським чи серверним. _Клієнтське програмне забезпечення_ відповідає за виведення контенту, наприклад, за кольори панелі навігації та стилі тексту. _Серверне програмне забезпечення_ відповідає за обмін, обробку та зберігання даних. За обробку мережевих запитів вашого браузера та взаємодію з базами даних в основному відповідає серверний код.

Node.js дозволяє розробникам використовувати JavaScript для створення серверного коду, хоча традиційно ця мова використовувалася в браузері для створення коду клієнта. Об'єднання клієнтського та серверного коду в одному середовищі розробки спрощує створення веб-серверів, і тому Node.js став популярним інструментом для написання серверного коду.

У цьому посібнику ми навчимося створювати веб-сервери за допомогою _npm_ - модуля `express`, що входить до складу Node.js. Ми створимо веб-сервери, які зможуть повертати дані JSON, CSV-файли та веб-сторінки HTML.

## Базові поняття та робота з Express

У традиційних динамічних веб-сайтах, веб-додаток чекає на HTTP-запит від веб-браузера (або іншого клієнта). Коли запит отримано, програма визначає, яку дію необхідно виконати на основі URL шаблону і, можливо, пов'язаної інформації, що міститься в даних POST або GET. Залежно від того, що потрібно, Express може потім читати або записувати дані з бази даних або виконувати інші завдання, відповідно до отриманого запиту. Потім програма повертає відповідь у веб-браузер, часто динамічно створюючи HTML-сторінку для відображення браузером, вставляючи вилучені дані в заповнювачі HTML шаблону.

Express надає методи, що дозволяють вказати, яка функція викликається для конкретного HTTP запиту (`GET`, `POST`, `SET`, etc.), і URL шаблон ("Route"), а також методи, що дозволяють вказати, який механізм шаблону ("view") використовується, де знаходяться шаблони файлів і який шаблон використовуватиме виведення відповіді. Ви можете використовувати Express middleware для додавання підтримки cookies, сеансів, і користувачів, отримання `POST`/`GET` параметрів, і т.д. Ви можете використовувати будь-який механізм бази даних, який підтримується Node (Express не визначає поведінку, пов'язану з базою даних).

У наступних розділах пояснюються деякі загальні моменти, які ви побачите під час роботи з кодом _Express_ and _Node_.

### Helloworld Express <a href="#helloworld_express" id="helloworld_express"></a>

Спочатку давайте розглянемо стандартний приклад Express Hello World (ми обговоримо кожну частину цього нижче та у наступних розділах).

{% hint style="info" %}
Якщо у вас вже встановлено Node та Express, ви можете зберегти цей код у файлі з ім'ям app.js і запустити його в командному рядку, викликавши `node app.js`
{% endhint %}

{% code lineNumbers="true" %}
```javascript
var express = require('express');
var app = express();

app.get('/', function(req, res) {
  res.send('Hello World!');
});

app.listen(3000, function() {
  console.log('Example app listening on port 3000!');
});
```
{% endcode %}

Перші два рядки вимагають () (імпорт) модуля Express та створення програми Express. Цей об'єкт, який традиційно називається app, має методи для маршрутизації HTTP-запитів, налаштування проміжного програмного забезпечення, рендерингу уявлень HTML, реєстрації механізму шаблонів та зміни параметрів програми, які керують поведінкою програми (наприклад, режим середовища, чи чутливі визначення маршруту до регістру) . , і т.д.)

Середня частина коду (три рядки, що починаються з app.get) показує визначення маршруту. Метод app.get () вказує колбек-функцію, яка буде викликатися щоразу, коли є HTTP-запит GET шляхом ('/') щодо кореня сайту. Колбек-функція приймає запит та об'єкт відповіді як аргументи і просто викликає send() для відповіді, щоб повернути рядок «Hello World!»

Останній блок запускає сервер через порт 3000 і друкує коментар журналу в консоль. Коли сервер працює, ви можете перейти до `localhost: 3000` у вашому браузері, щоб побачити повернутий приклад відповіді.

### Імпорт та створення модулів

Модуль - це бібліотека / файл JavaScript, який можна імпортувати в інший код за допомогою функції require () Node. Express сам по собі є модулем, як і проміжне програмне забезпечення та бібліотеки баз даних, які ми використовуємо в наших програмах Express.

Наведений нижче код показує, як ми імпортуємо модуль на ім'я, використовуючи як приклад платформу Express. Спочатку ми викликаємо функцію require (), визначаючи ім'я модуля у вигляді рядка («express») та викликаючи повернутий об'єкт для створення програми Express. Потім ми можемо отримати доступ до властивостей та функцій об'єкта програми.

{% code lineNumbers="true" %}
```javascript
var express = require('express');
var app = express();
```
{% endcode %}

Ви також можете створювати власні модулі, які можна імпортувати таким же чином.

{% hint style="info" %}
Створіть свої власні модулі, тому що це дозволяє вам організувати ваш код у керовані частини - монолітну однофайлову програму важко зрозуміти і підтримувати. Використання модулів також допомагає вам керувати простором імен, оскільки під час використання модуля імпортуються лише ті змінні, які ви явно експортували.
{% endhint %}

Щоб зробити об'єкти доступними поза модулем, вам просто потрібно призначити їх об'єкту експорту. Наприклад, модуль `square.js` нижче являє собою файл, який експортує методи `area()` та `perimeter()`:

{% code lineNumbers="true" %}
```javascript
exports.area = function(width) { return width * width; };
exports.perimeter = function(width) { return 4 * width; };
```
{% endcode %}

Ми можемо імпортувати цей модуль, використовуючи `require ()`, а потім викликати експортовані методи, як показано:

{% code lineNumbers="true" %}
```javascript
var square = require('./square'); // Here we require() the name of the file without the (optional) .js file extension
console.log('The area of a square with a width of 4 is ' + square.area(4));
```
{% endcode %}

{% hint style="info" %}
Ви також можете вказати абсолютний шлях до модуля (або ім'я, як ми на початку).
{% endhint %}

Якщо ви хочете експортувати повний об'єкт в одному призначенні, а не створювати його за однією властивістю за один раз, призначте його для `module.exports`, як показано нижче (ви також можете зробити це, щоб зробити корінь об'єкта експорту конструктором або іншою функцією) :

{% code lineNumbers="true" %}
```javascript
module.exports = {
  area: function(width) {
    return width * width;
  },

  perimeter: function(width) {
    return 4 * width;
  }
};e
```
{% endcode %}

### Использование асинхронных API <a href="#ispolzovanie_asinkhronnykh_api" id="ispolzovanie_asinkhronnykh_api"></a>

JavaScript часто використовує асинхронні, а не синхронні API для операцій, виконання яких може зайняти деякий час. Синхронний API - це той, у якому кожна операція має завершитись до початку наступної операції. Наприклад, такі функції журналу є синхронними та виводять текст на консоль по порядку (перший, другий).

{% code lineNumbers="true" %}
```javascript
console.log('First');
console.log('Second');
```
{% endcode %}

На відміну від цього, асинхронний API - це той, у якому API почне операцію і відразу повернеться (до завершення операції). Після завершення операції API використовуватиме деякий механізм для виконання додаткових операцій. Наприклад, наведений нижче код виведе "Second, First", тому що хоча метод setTimeout() викликається першим і повертається негайно, операція не завершується протягом декількох секунд.

{% code lineNumbers="true" %}
```javascript
setTimeout(function() {
   console.log('First');
   }, 3000);
console.log('Second');
```
{% endcode %}

Використання асинхронних API-інтерфейсів, що не блокують, ще більш важливе в Node, ніж у браузері, оскільки Node - це однопотокове середовище виконання, кероване подіями. "Однопотоковий" означає, що всі запити до сервера виконуються в одному потоці (а не породжуються в окремих процесах). Ця модель надзвичайно ефективна з точки зору швидкості та ресурсів сервера, але це означає, що якщо будь-яка з ваших функцій викликає синхронні методи, виконання яких займає багато часу, вони блокуватимуть не тільки поточний запит, але й будь-який інший запит, що обробляється вашим веб-додатком.

Є кілька способів, якими асинхронний API повідомляє вашу програму про те, що вона завершена. Найпоширеніший спосіб - зареєструвати колбек-функцію при виклику асинхронного API, який буде викликатись після завершення операції. Це підхід, використаний вище.

{% hint style="info" %}
Використання колбеків може бути досить «брудним», якщо у вас є послідовність залежних асинхронних операцій, які мають виконуватися по порядку, тому що це призводить до кількох рівнів вкладених колбеків. Ця проблема широко відома як «пекло колбеків». Цю проблему можна вирішити за допомогою гарних методів кодування, використання такого модуля, як `async`, або навіть переходу до функцій `ES6`, таких як Promises.
{% endhint %}

{% hint style="info" %}
Загальною угодою для Node та Express є використання колбеків з помилками. У цій угоді перше значення у ваших колбек-функціях є значенням помилки, тоді як наступні аргументи містять дані про успіх. У цьому блозі є добре пояснення того, чому цей підхід корисний: шлях Node.js - розуміння колбеків з помилками (fredkschott.com).
{% endhint %}

### Створення обробників маршруту

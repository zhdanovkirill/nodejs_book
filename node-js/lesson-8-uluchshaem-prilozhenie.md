# Lesson 8 - Покращуємо додаток

## Основи шаблонів

Шаблон - це текстовий файл, що визначає _структуру_ або зовнішній вигляд вихідного файлу, з передбаченими позиціями, в які будуть поміщатися дані при відображенні за шаблоном (в _Express_ шаблони також називають _уявленнями_).

### Вибір шаблонів Express <a href="#vybor_shablonov_express" id="vybor_shablonov_express"></a>

У Express можна використовувати багато двигунів шаблонів, що відображають ( [template rendering engines](https://expressjs.com/en/guide/using-template-engines.html) ). У цьому посібнику для шаблонів буде використано [Pug](https://pugjs.org/api/getting-started.html) (раніше відомий як Jade). Це найбільш популярна в Node мова шаблонів, яка заявляє про себе так: чистий, чутливий до пробілів синтаксис для написання HTML, на який сильно вплинув [Haml](http://haml.info/) .

p align="justify"> Різні мови шаблонів використовують різні підходи для визначення зовнішнього вигляду і розмітки позицій для даних-деякі використовують HTML для визначення зовнішнього вигляду, тоді як інші застосовують різні формати розмітки, які потім повинні компілюватися в HTML. Pug – другого типу; він використовує _уявлення_ ( _representation )_ HTML, у якому перше слово у кожному рядку зазвичай представляє елемент HTML, а відступи у наступних рядках застосовуються, щоб представити вкладені елементи. Результатом є визначення сторінки, яке транслюється безпосередньо в HTML, і яке, ймовірно, короткіше та легше читається.

{% hint style="info" %}
Недолік застосування _Pug_ - це чутливість до відступів та пробілів (якщо додати зайву прогалину в "поганому" місці, можна отримати незрозумілий код помилки). Однак, якщо ваші шаблони вже діють, їх легко читати і підтримувати.
{% endhint %}

### Конфігурація шаблону <a href="#konfiguraciya_shablona" id="konfiguraciya_shablona"></a>

Коли створювався каркас веб-сайту _LocalLibrary,_ він був налаштований на використання [Pug](https://pugjs.org/api/getting-started.html). Можна було помітити, що модуль pug включений залежно у файлі **`package.json`** і встановлений `app.set(...)` як движок уявлень у файлі **`app.js`** . Ця установка показує, що двигун уявлень - pug, і що _Express_ повинен шукати шаблони в підкаталозі **`/views`** .

{% code lineNumbers="true" %}
```javascript
// View engine setup.
app.set('views', path.join(__dirname, 'views'));
app.set('view engine', 'pug');
```
{% endcode %}

Копіювати в буфер обміну

Якщо ви побачите вміст каталогу **`views`** , можна побачити файли з розширенням .pug, в яких шаблони уявлень за замовчуванням. Це подання для домашньої сторінки **`index.pug`** та базовий шаблон **`layout.pug`** , який слід замінити нашим вмістом.

```
/express-locallibrary-tutorial  //the project root
  /views
    error.pug
    index.pug
    layout.pug
```

### Синтаксис шаблонів <a href="#sintaksis_shablonov" id="sintaksis_shablonov"></a>

Приклад файлу шаблону (нижче) демонструє багато найбільш корисних рис Pug.

Спочатку відзначимо, що файл відображає структуру типового HTML-файлу, причому перше слів у (майже) кожному рядку є елементом HTML, а відступи використовуються, щоб показати вкладені елементи. Так, наприклад, елемент `body`знаходиться всередині елемента `html`, а елементи `p`(параграфи) - всередині елемента `body,`і таке інше. Невкладені елементи (тобто індивідуальні параграфи) розташовуються окремих рядках.

```pug
doctype html
html(lang="en")
  head
    title= title
    script(type='text/javascript').
  body
    h1= title

    p This is a line with #[em some emphasis] and #[strong strong text] markup.
    p This line has un-escaped data: !{'<em> is emphasised</em>'} and escaped data: #{'<em> is not emphasised</em>'}.
      | This line follows on.
    p= 'Evaluated and <em>escaped expression</em>:' + title

    <!-- You can add HTML comments directly -->
    // You can add single line JavaScript comments and they are generated to HTML comments
    //- Introducing a single line JavaScript comment with "//-" ensures the comment isn't rendered to HTML

    p A line with a link
      a(href='/catalog/authors') Some link text
      |  and some extra text.

    #container.col
      if title
        p A variable named "title" exists.
      else
        p A variable named "title" does not exist.
      p.
        Pug is a terse and simple template language with a
        strong focus on performance and powerful features.

    h2 Generate a list

    ul
      each val in [1, 2, 3, 4, 5]
        li= val
```

Копіювати в буфер обміну

Атрибути елементів визначені у дужках після відповідних елементів. У дужках розташовується список пар \*ім'я атрибута=значення,\*причому елементи списку поділяються комою або пропуском. Наприклад:

* `script(type='text/javascript')`,`link(rel='stylesheet', href='/stylesheets/style.css')`
* `meta(name='viewport' content='width=device-width initial-scale=1')`

Значення всіх атрибутів _екрануються_ (тобто такі символи як " `>`" замінюються еквівалентними кодами HTML як " `&gt;"`) , щоб запобігти JavaScript ін'єкції та міжсайтові атаки.

Якщо після тега стоїть знак = , наступний текст сприймається як _вираз_ JavaScript. Наприклад, нижче в першому рядку, вміст тега `h1`буде _змінною_ `title` (яка визначена у файлі або передана до шаблону з Express). У другому рядку вміст параграфа - це текстовий рядок, з'єднаний зі змінною `title`. У кожному випадку поведінка за замовчуванням - екранувати рядки.

```pug
h1= title
p= 'Evaluated and <em>escaped expression</em>:' + title
```

Копіювати в буфер обміну

Якщо після тега знак = відсутній, вміст розглядається як звичайний текст. У тексті можна вставити екрановані або неекрановані дані, використовуючи синтаксис `#{}`і `!{}`, як показано нижче. У простий текст можна вставляти "сирий" HTML.

```pug
p This is a line with #[em some emphasis] and #[strong strong text] markup.
p This line has an un-escaped string: !{'<em> is emphasised</em>'}, an escaped string: #{'<em> is not emphasised</em>'}, and escaped variables: #{title}.
```

Копіювати в буфер обміну

{% hint style="success" %}
Завжди бажано екранувати дані, отримані від користувачів (за допомогою синтаксису **`#{}`**). Дані, яким можна вірити (тобто підрахована кількість записів, можуть бути виведені без екранування значень).
{% endhint %}

Можна використовувати символ конвеєра (' **|** ') на початку рядка, щоб відзначити простий текст (" [plain text](https://pugjs.org/language/plain-text.html) "). Наприклад, додатковий текст, наведений нижче, буде показаний у тому ж рядку, що й попередній, але не ставитиметься до посилання.

```pug
a(href='http://someurl/') Link text
| Plain text
```

Копіювати в буфер обміну

Pug дозволяє виконувати умовні операції `if`, `else`, `else if`і `unless`приклад наведений нижче:

```pug
if title
  p Переменная с именем "title" существует
else
  p Переменной с именем "title" не существует
```

Копіювати в буфер обміну

Можна також виконувати цикли (ітерації), використовуючи синтаксис `each-in`або `while`. Фрагмент коду (нижче) містить цикл елементів масиву, щоб показати список елементів (зазначимо застосування 'li=' для оцінки "val" як змінної). Значення ітератора val може бути також передано шаблон як змінна!

```pug
ul
  each val in [1, 2, 3, 4, 5]
    li= val
```

Копіювати в буфер обміну

Синтаксис дозволяє також коментарі (які потраплять у результат чи ні, на ваше бажання), суміші для створення повторно використовуваних блоків коду, оператори вибору case, та багато іншого. Більш детальна інформація - у документації [The Pug docs](https://pugjs.org/api/getting-started.html) .

### Розширення шаблонів <a href="#rasshirenie_shablonov" id="rasshirenie_shablonov"></a>

Прийнято мати загальну структуру всіх сторінок сайту, включаючи стандартну HTML-розмітку для заголовка, футера, навігації тощо. Замість того, щоб змушувати розробників дублювати ці зразки на кожній сторінці, _Pug_ дозволяє оголосити базовий шаблон, а потім модифікувати його, замінюючи лише ті невеликі частини, які є різними на кожній конкретній сторінці.

Наприклад, базовий шаблон **layout.pug** , створений у фреймворку, виглядає так:

```pug
doctype html
html
  head
    title= title
    link(rel='stylesheet', href='/stylesheets/style.css')
  body
    block content
```

Копіювати в буфер обміну

Тег `block`застосований для позначки розділів контенту, які можуть бути замінені на похідні шаблону (якщо блок не перевизначається, буде використовувати його реалізація в базовому класі).

Умовчання для **index.pug** (створений для каркасу проекту) показує, як можна замінити базовий шаблон. Тег `extends`ідентифікує базовий шаблон, який слід використовувати, а потім ми використовуємо, `block section_name,`щоб відзначити новий контент розділу, який ми замінюємо.

```pug
extends layout

block content
  h1= title
  p Welcome to #{title}
```

Як результат ми можемо створювати будьякі шаблони на стороні бекенду і без проблем використовувати їх наприклад в мейл сплвіщеннях.

Розглянемо [приклад за поселанням](https://expressjs.com/en/guide/using-template-engines.html)

## E-mail посилання <a href="#e-mail" id="e-mail"></a>

Будучи інструментом на стороні сервера, Node.js дозволяє надсилати електронні листи декількома способами, найпоширенішими з яких є використання SMTP та API. Давайте швидко розглянемо їх, як вони працюють і відрізняються один від одного. &#x20;

Варіант 1. Надсилайте електронні листи за допомогою Node.js і SMTP

Варіант 2. Надсилайте електронні листи в Node.js і API електронної пошти

Для надсилання електронної пошти в Node.js додатках використовується npm модуль `nodemailer`.

### Чи надсилати листи лише за допомогою Nodemailer?

У деяких посібниках і навчальних посібниках ви можете знайти примітку про те, що існують різні пакети електронної пошти Node.js, і вони є. Але насправді Nodemailer є найнадійнішим, і ви навряд чи зможете знайти гідну альтернативу.\
\
На Github ви можете знайти кілька пакетів для Node.js, пов’язаних із електронними листами, але вони не запропонують вам широку функціональність.

За допомогою Nodemailer ви можете створювати як звичайні текстові, так і HTML-електронні листи з вкладеннями та надсилати їх через SMTP, SES (обгортка для надсилання електронних листів через AWS SES) або _sendmail_ .\


1. Найбільш схожим пакетом є [Emaijs](https://github.com/eleith/emailjs) . Його особливості включають:

* Надсилання електронних листів через SMTP-сервери (SSL і TLS) з аутентифікацією
* Підтримка HTML і вкладення MIME. Ті, які також можна додати як:\

  * рядки
  * Потоки
  * Шляхи до файлів\

* Асинхронне надсилання листів із черги&#x20;
* Кодування UTF-8 у заголовках і тілі.\


Отже, основна відмінність полягає в тому, що в Emailjs ви використовуватимете тип MIME для роботи з вкладеннями, тоді як у Nodemailer ви використовуєте рядки.

1. Ще одним досить популярним пакетом є [email-templates](https://github.com/niftylettuce/email-templates) . Як видно з назви, цей пакет призначений для створення різних власних шаблонів для Node.js. Він підтримує:

* Автоматичний вбудований CSS&#x20;
* Таблиці стилів
* Вбудовані зображення
* Шрифти

Крім того, у ньому є опція попереднього перегляду, де ви можете перевірити, як одержувач побачить електронний лист. Пакет шаблонів електронної пошти створено творцем фреймворку [Lad . ](https://lad.js.org/)Тому рекомендується використовувати його з Lad.

1. Варто згадати ще один пакет [M ](https://github.com/eladnava/mailgen)[ailgen](https://github.com/eladnava/mailgen) . Він спрямований на створення HTML-шаблонів для транзакційних електронних листів. На Github є примітка, що за допомогою Mailgen ви можете «програмно створювати красиві електронні листи за допомогою звичайного старого [JavaScript](https://hackr.io/blog/how-to-learn-javascript) ». Пакет включає:

* кілька тем з відкритим кодом&#x20;
* спеціальні елементи (таблиці, кнопки дій тощо)

Ви вибираєте, як надсилати електронний лист, створений за допомогою Mailgen, але вони рекомендують перевірити Nodemailer для цієї мети.&#x20;

Nodemailer — це найпопулярніший пакет, який пропонує функції як для створення електронної пошти, так і для її надсилання. Він не обмежується одним способом надсилання.\
\
Але створити спеціальний шаблон електронної пошти буде непросто. За відсутності реальної альтернативи, яка перевершує Nodemailer за функціональністю, оптимальним шляхом є використання його в поєднанні з іншим пакетом.

Щоб знайти всі пов’язані пакети та плагіни, [знайдіть nodemailer](https://www.npmjs.com/search?q=nodemailer) у npm.

Почнемо з встановлення `nodemailer`

```bash
npm install nodemailer --save
```

Розробники модуля `nodemailer` зробили все, щоб його використання в `Node.js` було якомога простішим.

<pre class="language-javascript"><code class="lang-javascript"><strong>const nodemailer = require('nodemailer')
</strong>let testEmailAccount = await nodemailer.createTestAccount()
let transporter = nodemailer.createTransport({
  host: 'smtp.ethereal.email',
  port: 587,
  secure: false,
  auth: {
    user: testEmailAccount.user,
    pass: testEmailAccount.pass,
  },
})

let result = await transporter.sendMail({
  from: '"Node js" &#x3C;nodejs@example.com>',
  to: 'user@example.com, user@example.com',
  subject: 'Message from Node js',
  text: 'This message was sent from Node js server.',
  html:
    'This &#x3C;i>message&#x3C;/i> was sent from &#x3C;strong>Node js&#x3C;/strong> server.',
})

console.log(result)</code></pre>

Насамперед необхідно створити так званий `transporter`, який зберігає всю конфігурацію SMTP. Для створення `transporter`використовується метод `createTransport()`, який приймає об'єкт із наступними полями:

* `host`- адресу поштового сервера, який надсилатиме e-mail, що посилається;
* `port`- порт поштового сервера, за замовчуванням може бути `25`, `465`або `587`;
* `secure`- булеве значення, задається `true`, якщо використовується SSL, у разі значенням port має бути `465`;
* `auth`- об'єкт з властивостями `user`і `pass`, в яких вказується логін та пароль поштового облікового запису відповідно.

У разі відсутності реального облікового запису в процесі розробки можна використовувати тестовий поштовий обліковий запис `ethereal`, що входить до модуль `nodemailer`. Обліковий запис створюється викликом методу `createTestAccount()`, який повертає логін і пароль для доступу до облікового запису.

Щоб надіслати повідомлення через обліковий запис сервісу Gmail, `createTransport()`необхідно передати таку конфігурацію.

```
let transporter = nodemailer.createTransport({
  service: 'gmail',
  auth: {
    user: 'youremail@gmail.com',
    pass: 'yourpassword',
  },
})
```

Сама відправка e-mail здійснюється викликом методу `sendMail()`об'єкта `transporter`. Метод `sendMail()`приймає об'єкт із наступною структурою:

* `from`- email адреса відправника повідомлення, додатково може бути вказано ім'я (див. приклад);
* `to`- адресу одержувача, через кому або у вигляді масиву можна вказати безліч одержувачів;
* `subject`- Тема повідомлення;
* `text`- Текст повідомлення;
* `html`- текст повідомлення у форматі HTML;
* `attachments`- Прикріплені до повідомлення файли.

Розглянемо приклад надсилання e-mail із файлами.

```
await transporter.sendMail({
  from: '"Node js" <nodejs@example.com>',
  to: 'user@example.com, user@example.com',
  subject: 'Attachments',
  text: 'This message with attachments.',
  html:
    'This <i>message</i> with <strong>attachments</strong>.',
  attachments: [
    { filename: 'greetings.txt', path: '/assets/files/' },
    {
      filename: 'greetings.txt',
      content: 'Message from file.',
    },
    { path: 'data:text/plain;base64,QmFzZTY0IG1lc3NhZ2U=' },
    {
      raw: `
          Content-Type: text/plain
          Content-Disposition: attachment;

          Message from file.
        `,
    },
  ],
})
```

Файли відправляються масивом як `attachments`. Кожен елемент масиву описує один файл об'єктом наступної структури:

* `filename`- Ім'я файлу в повідомленні;
* `content`- Вміст файлу;
* `path`- шлях до файлу, який буде переданий потоком, його ім'ям буде значення, вказане у `filename`;
* `href`- шлях до файлу, який буде вкладено у повідомлення;
* `contentType`- Тип вмісту файлу;
* `contentDisposition`;
* `encoding`- Кодування вмісту файлу;
* `raw`- Завдання файлу в "сиром" форматі.

Якщо ви додаєте функцію надсилання електронних листів у свою програму Node.js, швидше за все, ви використовуватимете Nodemailer. Це найпростіший і найпопулярніший варіант надсилання, сумісний з іншими пакетами.

Яким би маршрутом ви не вибралися, завжди вибирайте варіант, який найкраще відповідає вашому поточному середовищу та потребам. Тільки не забудьте перевірити та налагодити свої тестові електронні листи, перш ніж доставити їх своїм клієнтам.

## Архітектура складних програм

### Що таке Чиста Архітектура

\
Для того щоб зрозуміти це, найкраще прочитати книгу [Мартіна Роберта «Чиста Архітектура»](https://www.ozon.ru/context/detail/id/144499396/) ( [Robert C.Martin «Clean Architecture»](https://www.amazon.com/Clean-Architecture-Craftsmans-Software-Structure/dp/0134494164) ). Коротка витримка з якого наведена у [статті за посиланням](https://habr.com/ru/post/269589/) .\
\
Основні ідеї закладені в архітектуру:

1. **Незалежність від фреймворку.** Архітектура залежить від існування будь-якої бібліотеки. Це дозволяє використовувати фреймворк як інструмент замість того, щоб втискати свою систему в рамки його обмежень.
2. **Тестованість.** Бізнес-правила можуть бути протестовані без інтерфейсу користувача, бази даних, веб-сервера або будь-якого іншого зовнішнього компонента.
3. **Незалежність від UI.** Інтерфейс користувача можна легко змінити, не змінюючи решту системи. Наприклад, веб-інтерфейс може бути замінений на консольний без зміни бізнес-правил.
4. **Незалежність від бази даних.** Ви можете змінити Oracle або SQL Server на MongoDB, BigTable, CouchDB або ще щось. Ваші бізнес-правила не пов'язані з базою даних.
5. **Незалежність від будь-якого зовнішнього сервісу.** За фактом, ваші бізнес правила просто нічого не знають про зовнішній світ.

<figure><img src="../.gitbook/assets/image (1) (3).png" alt=""><figcaption></figcaption></figure>

Досягається така гнучкість за рахунок поділу програми на шари Service, Repository, Model. Можна виділити такі основні шари.&#x20;

* **View** - виводить дані клієнту, фактично візуалізує стан логіки клієнта.
* **Controller** - відповідає за взаємодію з користувачем за допомогою IO (введення-виведення).
* **Service** - відповідає за бізнес логіку та її перевикористання між компонентами.
* **Repository** - відповідає за отримання даних із зовнішніх джерел, такі як база даних, api, локальне сховище та ін.
* **Models** – відповідає за перенесення даних між шарами та системами, а також за логіку обробки цих даних.

### Паттерн Controller

**Controller** - відповідає за взаємодію користувача з програмою. Це може бути клік по кнопці на веб-сторінці, настільному додатку, мобільному додатку, або введення команди в консолі лінуксу, або мережевий запит, або будь-яка інша IO подія, що приходить в додаток.\
Паттерн Service

### Паттерн **Service**

**Service** - відповідає за всю бізнес логіку програми. Якщо Controller'у знадобилося отримати, обробити, відправити якісь дані - він робить це через Service. Якщо кільком контролерам знадобилася та сама логіка, вони працюють з Service. Але сам шар Service нічого не повинен знати про шар Controller і View і оточення в якому він працює.

### Паттерн Repository

**Repository** - відповідає за спілкування зі сховищем даних. В якості сховища може виступати сервер, база даних, пам'ять, місцевізаписи, sessionstorage або будь-яке інше сховище. Його завдання абстрагувати шар Service від конкретної реалізації сховища.

### Моделі: DTO, Entities, ViewModels

**Models** - відповідає за опис структур з якими працює програма. Такий опис дуже допомагає новим розробникам проекту зрозуміти з чим працює програма. Крім того, його дуже зручно використовувати для побудови баз даних або проведення валідацій даних, що зберігаються в моделі.\
\
Моделі в залежності від типу використання поділяються на різні патерни:\


* **Entities** - відповідають за роботу з базою даних і являють собою структуру повторюючу таблицю або документ у базі даних.
* **DTO (Data Transfer Object)** – служать для перенесення даних між різними шарами програми.
* **ViewModel** — містять заздалегідь підготовлену інформацію, необхідну для відображення в поданні.

Дотримуватись цих простих правил не важко і вони збережуть вам багато часу в майбутньому. Розділяючи ПЗ на шари і дотримуючись _Правилу Залежностей_ ви створюватимете систему тестованої, з усіма перевагами.\
